<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-笨鸟起飞记</title><link>http://www.cnblogs.com/ansn001/</link><description>To be NO. 1000!!!!</description><language>zh-cn</language><lastBuildDate>Mon, 28 Dec 2015 23:19:14 GMT</lastBuildDate><pubDate>Mon, 28 Dec 2015 23:19:14 GMT</pubDate><ttl>60</ttl><item><title>2015有得有悟,2016笨鸟起飞</title><link>http://www.cnblogs.com/ansn001/archive/2015/12/28/5081435.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 28 Dec 2015 09:48:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/12/28/5081435.html</guid><description><![CDATA[穷人在怀疑中拒绝，富人在怀疑中了解！
# 有得有悟
2015年，是心里比较安稳的一年。收获挺大，关键的是一整年心态比较平和，所有的一切比较稳定。
## 学会看书
以前只知道看书重要，但是不明白为什么看书重要，更不会看书，所以收获很少。
2015年看了30多本书，比入行到现在加起来的还多（可见以前多么不会看书）。也慢慢学会了系统看书和收获知识、能力的技能。也养成了每天两小时以上看书习惯。从书中收获知识的速度比自己跌跌撞撞学习的要快太多。力推《如何阅读一本书》。
个人的感悟，看书之前一定要想清楚自己看书的真正目的。
### 目的
把世界的知识转化为属于自己的知识或者能力。
### 步骤
1. 细化学习的目的。了解（了解概念或者知道有这么个东东），入门（学习技术语法和思维），会用（掌握使用这个技术或者能力的经典应用场景），精通（整体解决方案）。
2. 找比较好的专业的作品（最好是书，视频、系列博客，帮助文档等），根据不同的目的去学习。
3. 练习反思总结2次以上。
4. 不断循环1-3直到出知识脉络xmind。
5. 编写修订文档（可以是博客，可以是为知笔记，可以其他任何形式的文档）。
6. 重新总结写出知识脉络xmind。

### 产出
必须要有固化的资源（建议是博客、xmind、文档）。
## 发现修身的重要性
以前纯粹在学习技术，然后学得比较累、比较苦，不明原因。后面慢慢明白，除了实实在在可以衡量的技术（硬能力），其实还需要很多的不可衡量的能力（软能力）。
以前觉得不会看书。后来才发现，是对应的软能力缺少太多。比如：心智、速读能力、学习的能力、阅读的能力、知识积累的能力等。
以前觉得不会沟通。后来才发现，是对应的软能力缺少太多。比如：人性的弱点，说的能力，听的能力，过滤信息的能力等。
现在对软能力的渴望和硬能力一样，甚至更为重要。因为软能力只要学会了，会受用钟生，而硬能力有可能会过时。
有这些能力会事半功倍，而且很快乐。没有这些能力会事倍功半，而且会很痛苦。
### 自我激励
简单说：有一颗变得更优秀的心。推荐《一万小时的天才》。
### 心智
是对事物的一个判断标准。力荐《把时间当作朋友》。
### 性格
毕竟是人与人的相处。如果性格不好，肯定是要吃亏的。力荐《人性的弱点》。
### 基本文字能力
很多时间我们是不具备文字能力的。基本的听、说、读、写其实都是不具备。所以在解决问题的时候会浪费大量的时间。力荐《如何高效阅读》。
### 沟通
人性都是有弱点的。沟通没有对与错，只有接受与不接受。
### 时间管理（GTD）
时间是不可逆的，是最宝贵的资源。所以要管理好我们的时间。力荐《小强升职记》。
### 知识管理
人的脑子来用于创造，不是用来记忆的。推荐使用wiz（为知）来构建和整理自己的能力体系。
### 结果导向
任何事情都是要结果的，否则就判断不了得与失、对与错。这个结果，可能是一个实在的东西，可能是一个虚拟的过程，要清晰的定位结果，然后做成它。
### 逻辑思维
解决和分析问题的基本能力。推荐《学会提问》

## 初悟解决问题之道
如果掌握正式的姿势，是可以解决自己不会的问题的。
以前只会解决会的或者说看似会的问题。慢慢发现，其实掌握了解决问题之道，完成可以解决自己不会的问题。因为事物的很多客观本质抽象是一致的。
1. 分而治之之道。
2. 系统思考之道。推荐《第五项修炼》。
3. 聚集答案型思维方式去解决问题。力荐《不懂带人，你就自己干到死》。

## 架构入门
以前只是一个coder，现在是一枚更高级的coder哈。虽然也一直在coding，也狂热coding。但是慢慢跳出了纯粹编码或者做项目的层次，慢慢也能体会什么叫技术选型、什么叫构架。个人的感悟，只有满足业务的架构才是好架构，适合才是完美的。个人总结的几个架构层次：
### 快速响应业务架构
专注业务、快速响应。解决除了业务的一切重复的事：重复的编码、重复的思考、重复的手工操作等。
1、搭建各种环境：开发、资源、测试、正式环境。
2、使用统一的研发软件、规范、流程和标准，降低复杂度。
3、使用统一的管理软件，提高管理效率。推荐worktile（敏捷的项目管理）、wiz（团队知识积累）两个软件。
4、使用自动化来解决重复的问题。比如：自动化集成(hudson)来解决在软件构架中的重复手工劳动，通过maven来解决项目管理问题。

### 分布式业务架构
支持SOA。以共享服务，管理服务，以便支持复杂的业务需求。
1、研发中的项目分布式分层规划。
2、应用对应的分布式设计（数据库、缓存、web应用）。
3、服务之间调用的整体解决方案。
4、自动化集成的支持。

### 高质量的分布式业务架构
为了满足大并发、大用户量、大数据量的情况下的业务支持。
1、 高可用。
确保网站在99.99%时间下是可用的。包括细则：安全、单点故障、监控、灾难恢复、数据备份等一系列概念。
2、 高性能
确保网站在大并发、大数据量、大事务量等情况下是可用的。包括细则：消息队列、优化（应用、操作系统）、缓存、负载均衡、集群、全文索引、静态化等一系列概念.
3、 高伸缩
在管理服务应用（增减机器，增减服务）情况下是可用的。包括细则：暂时不详。
4、 高扩展
在扩展业务（比如添加一个业务）的情况下是可用的。包括细则：暂时不详。

### 智能业务架构
采取更为智能的方式去提供个性化、更智能、更准确的业务支持。
1、 大数据
能通过大数据真实的为业务的个性化、方向做指导。
2、 云计算
能通过云计算，解决更合理使用资源的问题。
3、 机器学习
这个现在不详。

## 关注资源
不知道从什么时候开始，有可能在有的时候和大神、韬哥、老婆聊天的时候涉及到的，有可能是现在在平常的思考感悟，愈发觉得一个人的能力再怎么厉害也是有限的必须要有更广阔的资源。所以也开始涉猎。这样会有更广阔的解决问题的能力。
### 提升自己
提升自己的含金量，这样才能吸引到更多的资源。比如编写博客（强烈建议，因为这个可能锻炼非常多的能力）、发布开源等。
### 帮助并引导身边的人
独乐乐不如众乐乐。引导好身边的人，然后他们再去引导别人，然后然后。。。这样过不了多久，资源会非常可怕。这是向下扩展资源，树状扩展资源，太可怕！
### 扩大圈子
参与开源、沙龙等。多参与一些活动。平面关联扩大资源。

## 家庭幸福
幸福是不需要对比就会更开心的事情。
1. 多一个健康可爱的儿子。
2. 家人健康。
3. 没外债。

#笨鸟起飞
脚踏实地的打了几年的基础，2016年想起飞获得点实实在在的东西。
## 平和的心态
遇到任何事都不要紧、不要怕，冷静客观地想一想怎么解决。
### 方式
1. 所有事情都没有想象的那么紧急。把事情紧急程度放慢一个节奏。
2. 遇到越大的事，越要冷静的分析一下。
3. 遇到再大的问题，也想一想好的地方。

## 身体健康
### 方式
1. 瘦到150（现在160多）斤。
2. 调整好休息时间。 推荐《精力管理》

## 提升个人能力
### 方式
1. 心智。
2. 心态。
3. 基础能力。

## 提升职业含金量
### 方式
1. 架构日均百万PV的业务。
2. 有一套完整、轻便、可执行的软件质量把控流程。

## 扩大圈子
### 方式
1. 搭建学习型组织。
2. 参与沙龙。

## 家庭美满
想来点不一样的激情,现在的生活比较平淡
### 方式
1. 出国旅游。
2. 改变周末的生活方式（一天外出，一天家里休息）。

## 赚点小钱
有点小钱，解决即将到来的问题。至少能存够在老家买套房子的首付。
### 方式
1. 职业成长为架构中型企业的架构师。

附件
[2016年职业计划](https://github.com/ansn001/cto/blob/master/%E8%AE%A1%E5%88%92/%E4%B8%AA%E4%BA%BA/2016/%E8%81%8C%E4%B8%9A%E8%AE%A1%E5%88%92.xmind)]]></description></item><item><title>2015年11月书单推荐</title><link>http://www.cnblogs.com/ansn001/archive/2015/12/02/5013570.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Wed, 02 Dec 2015 09:13:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/12/02/5013570.html</guid><description><![CDATA[穷人在怀疑中拒绝，富人在怀疑中了解！
# 硬能力
就是实实在在的有对应的技术对应的能力
## 高性能MySQL（第3版）
这本书真是能读哭的书。里面的关于数据库复制的几章，原则讲的通透，图形生动，还有重要的配置和步骤。里面关于云数据库的观点很有收获。其他的章节大家可以根据需求来看。有讲硬件的，有讲基准的，有讲优化的。
## 精通安卓（第4版）
这本书前5章，理论讲得很具体，对安卓平台有个大概的了解。后面讲的都是具体的各种实现，适合于安卓开发的童鞋们使用
## 大型网站技术架构核心原理与案例分析
对于普及网站架构的概念确实是一本神书。绝对不是代码党。很适合看完反思。
# 软能力
没有实实在在的技术可以对应，但是对生活和工作却有很重要的影响
## 创业维艰
这本书吸引我的是——各种在创业公司遇到的各种场景的应对方法。刚好也是我需要的
## 联盟
讲的是互联网怎么留住人才和吸引人才的办法。对于里面的互利互惠以及任期，深表赞同，并且学习中]]></description></item><item><title>单元测试——测试神器，testng</title><link>http://www.cnblogs.com/ansn001/archive/2015/11/12/4958875.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Thu, 12 Nov 2015 06:35:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/11/12/4958875.html</guid><description><![CDATA[# 为什么用它
建议使用 TestNG 作为 Java 项目的主要单元测试框架，因为 TestNG 在参数化测试、依赖测试以及套件测试（组）方面功能更加强大。TestNG 意味着高级的测试和复杂的集成测试。它更加的灵活，特别是对大的套件测试。另外，TestNG 也涵盖了 JUnit4 的全部功能。那就没有任何理由使用 Junit了
更多细节，可以参见：[JUnit 4 与 TestNG 对比](http://fuxueliang.com/java/2013/06/26/junit-4-vs-testng--comparison/)

# 解决什么问题
* 断言结果
* 期望异常
* 进行分组
* 多线程测试
* 依赖测试
* 有测试可视化结果

即：它即能测试单元测试，也能进行集成测试，甚至也可以使用于系统测试（比较少用）。

# 基本概念
## 概论
TestNG，即Testing, Next Generation，下一代测试技术，是一套根据JUnit 和 NUnit思想而构建的利用注释来强化测试功能的一个测试框架，即可以用来做单元测试，也可以用来做集成测试
## 组成
1. 一套测试（suite）由一个XML文件所表示。它能够包含一个或者多个测试， <suite> 标记来定义。
2. test由 <test> 标记来表示一个测试，并且可以包含一个或者多个TestNG类。
3. TestNG 类是包含至少一个TestNG annotation的 java类，由<class>标签描述并包含一个或多个测试方法。
4. 测试方法，就是一个普通的Java方法，在由@Test标记。

# 使用场景
使用场景是按注解来陈述的，没有列举全部注解，更多注解可以参见：[TestNG基本注解](http://www.yiibai.com/testng/20130914295.html)
## @BeforeClass
用于集成测试或者其他依赖的初始。比如数据库的初始
## @AfterClass
用于测试的资源销毁。建议尽量不用。
## @Test
用于标记需要测试的方法。一般在类里`import static org.testng.Assert.*;`，这样方法的时候更优雅。
### 断言
在方法里，通过assertXxx系列来断言结果
```
@Test
public void assertResult() {
	String result = "result";
	//断言结果值等于
	assertEquals("result", result);

	boolean isTrue = true;
	//断言结果真假
	assertTrue(isTrue);
	//其他的asertXxx系统自行查看API
}
```
### 异常
通过expectedExceptions属性来捕获异常
```
@Test(expectedExceptions = BusinessException.class)
public void expectedException() {
	Iterator i = mock(Iterator.class);
	when(i.next()).thenThrow(BusinessException.class);

	i.next();
}
```
### 线程
通过invocationCount和threadPoolSize属性来实现。
```
@Test(invocationCount = 8, threadPoolSize = 3)
public void testThread() {
	long threadId = Thread.currentThread().getId();
	System.out.println("线程号为：" + threadId);
}
```
执行结果
```
[ThreadUtil] Starting executor timeOut:0ms workers:8 threadPoolSize:3
线程号为：12
线程号为：13
线程号为：11
线程号为：12
线程号为：11
线程号为：13
线程号为：12
线程号为：13
PASSED: testThread
PASSED: testThread
PASSED: testThread
PASSED: testThread
PASSED: testThread
PASSED: testThread
PASSED: testThread
PASSED: testThread
```
### 依赖
通过dependsOnMethods、dependsOnGroups来实现。
```
@Test
public void preAction() {
	System.out.println("preAction");
}

@Test(dependsOnMethods = "preAction")
public void action() {
	System.out.println("action");
	//dependsOnGroups就不再做试验了
}
```
执行结果：
```
preAction
action
PASSED: preAction
PASSED: action
```
### 忽略
通过enable来实现
```
@Test(enabled=false)
public void disable(){
	//建议少用
	System.out.println("暂时不执行");
}
```
### 分组
通过groups来实现
```
@Test(groups = "database")
public void update() {
	IDbDao dbDao = mock(IDbDao.class);
	UserEntity user = new UserEntity();
	when(dbDao.fetch(UserEntity.class, 1L)).thenReturn(user);

	UserEntity fetchUser = dbDao.fetch(UserEntity.class, 1L);

	assertEquals(user, fetchUser);
}
```
# 测试报告
测试报告是测试非常重要的部分.  
TestNG默认情况下，会生产两种类型的测试报告HTML的和XML的。 测试报告位于 "test-output" 目录下.
# 参考资源
[官方文档](http://testng.org/doc/documentation-main.html)
[TestNG 入门教程](http://www.cnblogs.com/TankXiao/p/3888070.html)]]></description></item><item><title>单元测试——隔离神器：mockito</title><link>http://www.cnblogs.com/ansn001/archive/2015/11/05/4939518.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Thu, 05 Nov 2015 06:53:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/11/05/4939518.html</guid><description><![CDATA[mockito，一个让人着迷的单元测试隔离框架。对比了easymock,jmock,jmockito，最终选择了它。
# 为什么用他
1. 接口语法简洁、自然。写起来像在说话，很舒服。
2. 文档更完整。让学习曲线更简单。
3. 可以进行参数化。在很多情况下，不想关心具体的参数是什么。
4. mock的思路更舒服。废弃了陈旧的“录制——重放”的方法，使用的“期望——执行——断言”更自然的方法。

# 他能解决什么问题
1. 可以mock接口。
2. 可以破除不可控制的依赖。主要体现在：数据库、文件系统、http（`特别是在和第三方接口对接时`）等。
3. 模拟异常。

# 使用场景
## mock接口
```
Comparable c = mock(Comparable.class);
when(c.compareTo("Test")).thenReturn(1);

assertEquals(1, c.compareTo("Test"));
```
## 不关注参数
```
Comparable c = mock(Comparable.class);
//一旦使用anyXxx()系列，所有的方法参数都必须`全部`使用anyXxx()。
when(c.compareTo(anyString())).thenReturn(1);

assertEquals(1, c.compareTo("Test"));
```
## 破除不可控制的依赖
```
HttpServletRequest successRequest =mock(HttpServletRequest.class);
when(successRequest.getAttribute("status")).thenReturn("200");

OrderEntity order = finish(successRequest);

assertTrue(order.isOk());
```
## 模拟异常
```
OutputStream osMock = mock(OutputStream.class);
OutputStreamWriter osw = new OutputStreamWriter(osMock);
/*
 * 因为close()方法的返回值是void，所以只能用这只格式
 * 如果返回值不是void，也可以使用when(someMethod()).thenThrow(new Exception());
 */
doThrow(IOException.class).when(osMock).close();

osw.close();
```
## 更简洁的mock
通过注解Mock
```
@Mock
private Iterator i;

@BeforeClass
public void init() {
	//这个是必须的。
	MockitoAnnotations.initMocks(this);
}

@Test
public void annotationMock() {
	when(i.next()).thenReturn(1);

	assertEquals(1, i.next());
}
```
# 限制
对于final类、匿名类和Java的基本类型是无法进行mock。不过可以使用powerMock扩展。但是正常情况下是不需要的，除非对历史代码的单元测试
# 参考资源
1. [官方文档](http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html)
2. [中文文档](https://github.com/bboyfeiyu/mockito-doc-zh)
3. [快速上手](http://gojko.net/2009/10/23/mockito-in-six-easy-examples/)]]></description></item><item><title>2015年10月书单推荐</title><link>http://www.cnblogs.com/ansn001/archive/2015/11/04/4935427.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Wed, 04 Nov 2015 03:27:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/11/04/4935427.html</guid><description><![CDATA[穷人在怀疑中拒绝，富人在怀疑中了解！

# 硬能力
就是实实在在的有对应的技术对应的能力
## 单元测试的艺术（第2版）
本书适合精读。对于单元测试的整体的概念和分类讲的不错，适合新手对单元测试概念的恶补。而且也有对应的例子和工具，总的来说，相当不错。当然用的语言是c#，可以忽略语言本身，注意陈述的知识即可。
## 单元测试之道Java版：使用JUnit
本书适合速读。其中单元测试编写的细则分类写得不错。还有就是告诉我们从骨子里接受单元测试，告诉我们单元测试是一件有意义的事。举的两个大例子也可以说明为什么要用单元测试。
## 代码整洁之道
本书适合速读。想把代码写得更漂亮，像艺术品一样漂亮的童鞋，可以看一下。里面我比较有感触的：1）在编写方法的时候，要同一个抽象层次。2）类名本身不要有依赖。其他的大家可以自己收获。
## Linux Shell 脚本攻略（第2版）
本书适合精读。里面有些小技巧讲得比较有意思，偶尔也有概念讲得很吸引力。不过不是系统的linux，建议提前看一些入门书，比如《鸟哥的私房菜》。建议把感兴趣的技巧做标记，反复去实践。
## JavaScript高级程序设计（第3版）
本书适合精读。对于js语言的概念讲得非常深入、透彻。建议细细味一味。当然也是建议有选择的阅读，后面有一些章节，大家可以根据自己实际的角色需求选择。比如HTML5相关的特性以及一些新兴的js API。]]></description></item><item><title>UML类图的关系</title><link>http://www.cnblogs.com/ansn001/archive/2015/10/29/4919718.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Thu, 29 Oct 2015 03:36:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/10/29/4919718.html</guid><description><![CDATA[# 多态
## 泛化（Generalization）
【定义】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为
【UML表示】：带三角箭头的实线，箭头指向父类
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029105046325-675519189.png' style="margin-left:200px;"/>
【代码表现】：A类 extends B类
>public Class Tigger `extends` Animal{

## 实现（Realization）
【定义】：是一种类与接口的关系，表示类是接口所有特征和行为的实现
【UML表示】：带三角箭头的虚线，箭头指向接口
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029105257919-324040879.png' style="margin-left:200px;"/>
【代码表现】：A类 implements B接口
>public Class Course `implements` Goods{

# 依赖（Dependency）
【定义】：是一种使用的关系，即一个类的实现需要另一个类的协助
【UML表示】：带箭头的虚线，指向被使用者
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029105527935-1621370697.png' style="margin-left:200px;"/>
【代码表现】:局部变量、方法的参数或者对静态方法的调用
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029110211841-1702135053.png' style="margin-left:200px;"/>
# 关联
下面的三种关系从语法上是没有区别的。只是在语义是做区分。
## 关联（Association）
【定义】：是一种拥有的关系。类的地位还是平等的。
【UML表示】：带普通箭头的实心线，指向被拥有者
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029110638122-613003292.png' style="margin-left:200px;"/>
【代码表现】:成员变量
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029110815638-267093168.png' style="margin-left:200px;"/>
注意事项：
* 通常情况下关联是双向的，在使用的时候会转成单向。转成单身的原则：以业务关注点高的类为起点，关联另一个类。

## 聚合（Aggregation）
【定义】：是整体与部分的关系，且部分可以离开整体而单独存在，部分可以`多个`整体使用。类有上下层的关系。
【UML表示】：带空心菱形的实心线，菱形指向整体
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029111936919-1847897862.png' style="margin-left:200px;"/>
【代码表现】:成员变量
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029112142763-810574211.png' style="margin-left:200px;"/>
## 组合（Composition）
【定义】：是整体与部分的关系，但部分不能离开整体而单独存在，部分只能被`一个`整体使用。类有上下层的关系。它们的生命周期是：`同生共死`，即如果整体消失了，那么局部也会消失。
【UML表示】：带实心菱形的实线，菱形指向整体
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029112554169-1219881270.png' style="margin-left:200px;"/>
【代码表现】:成员变量
<img src='http://images2015.cnblogs.com/blog/762312/201510/762312-20151029112656419-286469782.png' style="margin-left:200px;"/>]]></description></item><item><title>单元测试——破除依赖</title><link>http://www.cnblogs.com/ansn001/archive/2015/10/27/4913517.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Tue, 27 Oct 2015 03:23:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/10/27/4913517.html</guid><description><![CDATA[# 痛点是什么
>要测试的对象依赖另一个你无法控制（或者还未实现）的对象。这个对象可能是Web服务、系统时间、线程调试、接口或者其他。
>重要的问题是：你的测试代码不能控制这个依赖的对象向你的代码返回什么值，也不能控制它的行为（例如想模拟一个异常）。

何以解忧，唯有`存根或者模拟对象`。
# 什么是存根
一个存根是对系统中存在的一个依赖项（或者协作者）的可控制的替代物。通过使用存根，你在测试代码时无需直接处理这个依赖项。
<img src="http://images2015.cnblogs.com/blog/762312/201510/762312-20151027104630544-651851225.png" width="80%"/>

# 什么是模拟对象
模拟对象是系统中的伪对象，它可以验证被测试对象是否按预期的方式调用了这个伪对象，因此通过或者是失败。通常每个测试最多有一个模拟对象

# 存根和模拟对象区别
它们二者其他都是伪对象。二者最根本的区别是存根不会导致测试失败，而模拟对象可以。即存根不参与断言，而模拟对象参与断言。
<img src="http://images2015.cnblogs.com/blog/762312/201510/762312-20151027110025669-1738661296.png" width="80%"/>



# 怎么实现
## 手工
竟然还想着手工实现。。。。但是还是简单说一下原理，如果有想深入了解，可以参见《单元测试的艺术》
* 加一个中间层，让测试类实现它，然后编写一个用于单元测试的实现类
* 继承测试类，编写一个单元测试的实现类，重写方法并赋值返回值。
* 通过工厂创建存根对象
* 通过Ioc创建存根对象
* 通过反射注入属性生成存根对象
* ......

## 框架
目前也在找比较适合的框架。所说EasyMock太过时了，还要使用PowerMock。Jmockito和其他的不受限的mock框架还在学习中。正在觅食一个能降低隔离复杂度的框架。
下面陈述一下我想找的隔离框架的几个特性
1. 支持AAA原则，即“准备——执行——断言”结果的框架，不大想用“录制——重放”的方法。因为不自然。
2. 框架必须是不受限的。可以支持静态方法，私有构建等。哈哈，因为我比较贪心
3. 框架有比较友好的文档。这样可以降低学习曲线。
4. 框架的语法，看得更自然舒服些。毕竟要用很久，顺眼很重要！！
5. 最好是能支持灵活的参数mock。就像EasyMock.anyString()。因为有些参数确实不想关心。]]></description></item><item><title>单元测试——基础概念</title><link>http://www.cnblogs.com/ansn001/archive/2015/10/26/4911623.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 26 Oct 2015 09:34:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/10/26/4911623.html</guid><description><![CDATA[# 前言
我们都写过的某种测试
>不要惊讶，你已经进行过某种程度的单元测试。你见过提交代码前不做测试的开发人员吗？
>在传统测试中，开发人员使用一个图形用户界面触发要测试的类的某个行为，然后检验结果。

那什么是单元测试，什么不是单元测试呢？
# 为什么不写单元测试
## 不想做
往往说不想的，其实是因为还不会。因为不会，所以想一想就很麻烦，还不如手工测试呢。
## 多余
>我已经写好代码，然后还要去确认写好的逻辑，好多余 

* 我们不能确保我们的代码是100%正确的。有可能因为精神不好，原因需要抛异常的地方，忘了写一个throw呢？结果原来需要回滚的事业，没正常回滚。
* 我们在写实现的有很多逻辑，甚至有一些异常处理。因为我们在假设某些场景。其实这些场景就是简单的单元测试。所以又写一遍会觉得很多余。
* 代码都实现完了，写单元测试干什么。其实代码还没有实现完！有可能还要重构，有可能你还需要排错，有可能别人接手你的代码。但是你没有一个办法保证你的代码一直是正确的。

因为我们没有遵循正确的TDD实践，所以觉得不舒服和多余。

## 经常修改
单元测试一旦通过，不会经常修改。一般有两大类经常修改情况：
* 确实需要修改单元测试，因为接口需求变更了。所以有些单元测试没有某些业务的考虑，所以要删除或者修改这些单元测试，否则反而会报红。
* 但是往往更多的是第二类。接口需求不变，重构的时候因为报红了，所以强行修改单元测试。因为依赖变了，甚至有些顺序变了，所以原来的单元测试报红了。那说明本来的被单元测试的代码本身就依赖性太强。一般需要修改的是重构代码本身。而且单元测试的每个case最好是隔离的。

## 太浪费时间
是的，单元测试确实会增加编码的时间。但是从整个软件的交付时间比来说，有好的单元测试的时间会交付更快。一般有健全的单元测试，在测试阶段和维护阶段会花费更少的时间。我们在做的是一个完整的软件，所以时间应该算总的周期
另外一个原因，有可能是因为不熟练或者没有合适的工具，所以花了大量时间在重复的工作之上。

## 不务正业
其实咱们一直在做不务正业的事。调试代码，给代码加注释，画流程图，上网解决问题等等。这些其实都是开发者的日常工作。所以单元测试也是！！

这里也有一篇文章，也比较有意思：[为什么要进行烦人的单元测试？](http://blog.csdn.net/happylee6688/article/details/37962283)

# 什么是单元测试
那到底什么是单元测试呢？
>一个单元测试是一段自动化的代码，这段代码调用被测试的。这段代码调用被测试的工作单元，之后对这个单元的单个最终结果的某些假设进行检验。单元测试几乎都是用单元测试框架编写的。单元测试容易编写，能快速运行。单元测试可可靠、可读，并且可维护。只要产品代码不发生变化，单元测试的结果是稳定的。

## 特性
* 它应该是自动化的，可重复执行。
* 它应该很容易实现
* 它应该第二天还有意义
* 任何人都应该能一键运行它
* 它应该运行速度很快
* 它的结果应该是稳定的（如果运行之间没有进行修改的话，多次运行一个测试应该总是返回同样的结果）
* 它应该能完全控制被测试的单元
* 它应该是完全隔离的（独立于其他测试的运行）
* 如果它失败了，我们应该很容易发现什么是期待的结果，进而定位问题所在

## 包含行为
1. 准备（Arrange)对象，创建对象，进行必要的设置
2. 操作（Act）对象
3. 断言（Assert）某件事情是预期的。

## 结果类型
从调用系统的一个公共方法到产生一个测试可见的最终结果，其间这个系统发生的行为总称为一个工作单元。一个最终结果有三种形式
1. 带有返回值的。即基于值的测试。
2. 在方法调用前后，系统的状态或者行为有可见的变化 ，这种变化无需查询私有状态即可判断。即基于状态测试。
3. 调用一个不受测试控制的第三方系统，这个第三方系统不返回任何值，或者返回值都被忽略。即交互测试。

## 验证
很多人把进行软件测试的行为和单元测试概念混为一谈。要澄清这个误解，你首先应该回顾自己以前写过的测试，问自己如下问题。
1. 我两周前写的一单元测试，今天还能运行并得到结果吗？几个月前的呢？几年前的呢？
2. 我两个月前写的单元测试，我团队里任何一个人都能运行它们并得到结果吗？
3. 我能在几分钟内跑完我写过的所有单元测试吗？
4. 我能一键运行我写过的所有单元测试吗？
5. 我能在几分钟写出一个基本的测试吗？
如果能的话，那就是单元测试。如果不能，那有可能就是集成测试。

# 什么是集成测试
那到底什么是集成测试呢？
>集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全的控制，并使用该单元的一个或者多个真实依赖物，何如时间、网络、数据库、线程或者随机数产生器等
>总的来说，集成测试会使用真实依赖物，而单元测试则把测试单元和基依赖物隔离开，以保证单元测试结果高度稳定

并不是说集成测试不重要！单元测试和集成测试具有同等重要的地位，但是这两个测试应该彼此分开，以营造一种“绿色安全区”的感觉
# 什么是TDD
上面说的是什么是单元测试。那么什么时候编写测试呢？很多人觉得为软件编写单元测试的最佳时机是软件编码完成以后，但是`越来越多的人选择在产品代码编写之前写单元测试`。这种方法称为测试优先或测试驱动开发（Test-Driven Development, TDD）。
执行步骤：
1. 编写一个会失败的测试，以证明产品中代码或功能的缺失。编写测试的时候，要假设产品代码已经能工作了，这样测试的失败就说明产品代码中有缺陷。
2. 编写符合测试预期的产品代码，使测试通过。产品代码应该尽量简单。
3. 重构代码。如果测试通过了，你就可以编写下一个单元测试，或者进行重构，使代码可读性更强，或者去除重复代码等。

即`红-->绿-->重构`

********
本文的概念大部分出自于《单元测试的艺术》，特此说明。因为书里的概念讲得是我想要的，比网上搜的其他资源要适合自己些。
更具体的概念可以翻阅《单元测试的艺术》。]]></description></item><item><title>2015年9月书单推荐</title><link>http://www.cnblogs.com/ansn001/archive/2015/10/02/4851912.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Fri, 02 Oct 2015 01:16:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/10/02/4851912.html</guid><description><![CDATA[最近在研发一个新的项目，所以自主的时间少了，但是书还是要读的。
越没钱，越要读书。越没能力，越要读书。越没时间，越要读书。因为书能快速的解决这些问题。
推荐几本上个月看的书。

# 硬能力
就是实实在在的有对应的技术对应的能力
## 《UML精碎》
本书适合速读。如果希望对UML的知识有个快速的了解，可以选择本书。对于每个UML的职责可以多品品。
## 《UML基础、案例和应用》
本书适合精读。对于各种UML图的职责及用途讲得非常用心。关键的是这本书比较接地气。怎么具体执行讲得也比较入理。
对于面向对象的分析过程，以用怎么使用UML实际的工作都有篇幅。
## 《写给大家看的设计书》
本书适合速读。讲了设计的4个基本原则以及颜色相关。可以简单快速的提升一定能力的产品审美观。

# 软能力
没有实实在在的技术可以对应，但是对生活和工作却有很重要的影响
## 《学会提问》 
本书适合先精读，有一定的整体认识。然后不断的精读，细细的品，然后转化为自己的思考方式或者思维习惯。
可以解决的问题：防止被人忽悠，防止被人灌输想法，找到问题背后真正的问题。
本书有比较完整的体系去实际。也就是传说中的套路。]]></description></item><item><title>菜鸟vimer成长记——第4.2章、编程插件</title><link>http://www.cnblogs.com/ansn001/archive/2015/09/07/4789461.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 07 Sep 2015 09:57:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/09/07/4789461.html</guid><description><![CDATA[# 简介
这部分的插件是与编程相关的插件。主要涉及两大块：所有编程语言通用的插件，以及各个语言独有的插件。插件的数量和合理性，这可能是一个不断累积和修正的过程。
个人感觉，现在比较适合sh,html,markdown的编程。对于java，还是有点勉强。至于其他的，比如python等，现在还没有涉略。还会继续边使用，边调整。

其实只要是编程的IDE都会涉及到一些统一的概念：快速查找文件，快速查找文本引用，高亮，语法错误提示，自动提示，快速输入，消除重复操作，项目的管理等。我个人目前的感觉是，vim在项目的管理方面不是那么舒服，和jdk+eclipse+maven比较起来没那么舒服。还有一些消除重复的操作，太有语言个性的vim也处理不是那么好，比如说eclipse的重构功能。所以，我个人感觉，目前来说，简洁的结构语言（并不是说语言本身简单，也是语言使用场景比较简洁），比如说bash,html,markdown处理起来会非常舒服。

以上属于个人理解，也欢迎大家讨论。
# 通用插件
这里面指的是各个编码语言常用的共通的一些习惯的插件。即适合用绝大部分语言。
## auto-pairs
配对插件，可以匹配这几个字符：<code>'</code>、<code>"</code>、<code>`</code>、<code>)</code>、<code>]</code>、<code>}</code>,再也不用担心漏写了。
注意事项：
1. 如果你不想配对，可以用Delete键删除
2. 在上面这几个符号后按回车键，会插入一个新的带缩进的行并且补齐配对符号
3. 可以使用包裹，不过我没试出来，上面写的是<M-e>,据说是meta|alt键。不过因为我的windows下的，所以按alt键会跳出菜单。

更多使用方式可以参看：[官方说明](https://github.com/jiangmiao/auto-pairs)
## nerdcommenter
添加注释。主要有两种风格：单行注释和多行注释。下面的所有命令在insert模式和visual模式都适用。所有的命令之前都有量词，即命令通用格式是{count}<leader>c*。<leader>一般默认是"/"，可以自行设定。
语法如下：
* cc : 添加注释
* cm : 添加多行注释
* ci : 添加单行注释
* cs : 优雅的添加注释。有一定格式的多行注释
* cy : 和cc一样并且把内容复制起来
* cA : 在行尾添加注释
* ca : 切换注释的风格（单行和多行间的切换）
* cu : 取消注释

没有特别说明的注释，都是指默认注释风格，这个可以通过ca来切换
## snipmate
编码中难免会有许多重复的代码片段，所以有了这类的插件。
注意事项：
1. 因为这里快捷键是<Tab>。和superTab插件的快捷键冲突。所以这里舍弃了superTab插件。
2. 支持自定义snipmate，所以大家可以根据自己的习惯去自定义常用的snipmate。

## tabular
文本对齐。
语法:[range]Tabularize /{string}
说明：
* [range]指的是规范，如果不指定默认指全文
* {string}可是一个字符也可以是多个字符

## AuthorInfo
添加文件的作者信息。
<img src="http://images2015.cnblogs.com/blog/762312/201509/762312-20150907174754106-960869102.png" width="100%" />

# html插件
更快捷的编写html
## emmet-vim
html插件的神器！！！这个网络上太多了，就不再班门弄斧了。
参考资源：
1. [自动生成HTML/CSS代码](http://www.jianshu.com/p/67fa1e2114c5)
2. [Emmet.vim 教程](http://banu.blog.163.com/blog/static/2314648201412705633704/)

# markdown插件
## vim-markdown
主要用于markdown的高亮、移动、预览等功能，让我们能更方便的编写markdown。
该插件，需要前置条件是需要安装tabular。
### 跳到标题
快速的跳到标题位置，方便在markdown文档里移动
语法如下：
`]]` : 跳到下一个标题
`[[` : 跳到上一个标签
`][` : 跳到下一个兄弟节点标题
`[]` : 跳到上一个兄弟节点标题
`]c` : 跳到当前的标题
`]u` : 跳到父标题
### 显示目录
根据标题生成一个可以浏览的目录导航，也可以根据导航移动
语法如下：
`:Toc`  : 生成一个标题的目录导航
`:Toch` : 生成一个标题的目录导航在底部显示
`:Tocv` : 生成一个标题的目录导航在右边显示
`:Toct` : 生成一个标题的目录导航在新的标签显示
# 配置文件
```
"========>>>>>>编程插件配置开始
"普通
"	括号匹配
Plugin 'jiangmiao/auto-pairs'
"	添加注释
Plugin 'scrooloose/nerdcommenter'
"	作者信息
Plugin 'vim-scripts/AuthorInfo'
"	文本对齐
Plugin 'godlygeek/tabular'
"	文本模板
Plugin 'msanders/snipmate.vim'
"markdown
Plugin 'plasticboy/vim-markdown'
"css+html+div
Plugin 'mattn/emmet-vim'
"========>>>>>>编程插件配置结束

"设置leader键
let mapleader=','
"===>>>AuthorInfo配置
let g:vimrc_author='Zhuang Junxiang'
let g:vimrc_email='529572571@qq.com'
let g:vimrc_homepage='www.cnblogs.com/ansn001'
nmap <F4> :AuthorInfoDetect<cr>
"===>>>vim-markdown配置
"默认不折叠
let g:vim_markdown_folding_disabled=1

```]]></description></item><item><title>菜鸟vimer成长记——第4.1章、通用插件</title><link>http://www.cnblogs.com/ansn001/archive/2015/08/27/4760192.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Thu, 27 Aug 2015 01:51:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/08/27/4760192.html</guid><description><![CDATA[# 简介
关于插件的分类，此系列只会简单的区分为通用插件和编程插件。通用插件的意思是，不基于任何编程语言都可以使用的插件。编程插件，是针对于编程习惯，或者说是针对于某种语言的插件。
计划中，是先把基本常用的插件先整理出来。后期如果有遇到更适合的插件也会添加进来。
下面的插件，如果没有特别说明都是基于Vundle管理的。这些插件都可以在github上搜到，一般是最受欢迎的那个，所以就不一一说明了。
有些插件的快捷键设置会统一在最后的配置文件体现，就不一一描述。

# 开始界面
## vim-startify
vim-startify是一个更改开始界面的插件，使用了之后启动vim就不会再看到版本信息的界面，而是一些快捷方式，如最近打开的文件，自己设置的bookmark，还有session等等,并且可以快速打开，非常的实用。
![](http://images0.cnblogs.com/blog2015/762312/201508/261359209062688.gif)

### 使用方式
![](http://images0.cnblogs.com/blog2015/762312/201508/261400182346302.gif)


如果直接vim不指定文件名，startify全显示一个小巧但精致的窗口。如果已经在编程文件，可以通过:Startify命令调出来这个窗口。
普通的打开文件方式。此时通过`j`,`k`来移动，确认要打开的时候按<CR>键。
更快的打开文件方式。列表上有数字，直接按对应的数字就可以打开。
更强的打开文件方式。可以通过操作，支持更丰富的窗口打开方式。先移动并按下面的操作方式，最后再统一按<CR>
* b 在同一个窗口打开
* s 水平分屏
* v 垂直分屏
* t 打开新的标签页

其他命令
* e 创建一个新的缓冲
* q 退出

更多细节，可以参见:h Startify。
# 配色
配色下完后，还需要把插件的color拷贝到指定的color目录（比如windows下，目录是$VIM/vimfiles/colors）。这里推荐两个：molokai、solarized
。大家自行下载。
# 窗口
<img src="http://images0.cnblogs.com/blog2015/762312/201508/261415493128852.jpg" width="100%" height="600px"/>
几个区域的解释
1. nerdtree窗口，浏览文件。
2. 文件编辑区。
3. tagbar窗口。
4. ariline窗口。文件状态。

##nerdtree
是一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录。内挂是谁呢:E，有兴趣的大神也可以去瞅一瞅。
###使用方式
```
#移动到文件窗口，一般是放置在左侧：ctrl+W+h。如果你是放右侧那就使用ctrl+w+l，也可以使用ctrl+W+w切换。
ctrl + w + h    光标 focus 左侧树形目录
#打开文件。有加g和没加g的区别是：加g，光标还在文件目录上；没加g，光标会跳到新窗口或者标签
o       在已有窗口中打开文件、目录或书签，并跳到该窗口
go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口
t       在新 Tab 中打开选中文件/书签，并跳到新 Tab
T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab
i       split 一个新窗口打开选中文件，并跳到该窗口
gi      split 一个新窗口打开选中文件，但不跳到该窗口
s       vsplit 一个新窗口打开选中文件，并跳到该窗口
gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口
#展示收缩文件
O(大写o)递归打开选中 结点下的所有目录
x       合拢选中结点的父目录
X       递归 合拢选中结点下的所有目录
#编程当前文件
e       Edit the current dif
D       删除当前书签
#在文件目录间移动
P       跳到根结点
p       跳到父结点
K       跳到当前目录下同级的第一个结点
J       跳到当前目录下同级的最后一个结点
k       跳到当前目录下同级的前一个结点
j       跳到当前目录下同级的后一个结点
#切换根目录，即显示文件目录
C       将选中目录或选中文件的父目录设为根结点
u       将当前根结点的父目录设为根目录，并变成合拢原根结点
U       将当前根结点的父目录设为根目录，但保持展开原根结点
#刷新文件目录
r       递归刷新选中目录
R       递归刷新根结点
#快速切换工作目录
cd      将 CWD 设为选中目录
#退出
q       关闭 NerdTree 窗口
```
##vim-airline
这是一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件。
安装完不需要我们做什么就可以使用了。
我比较懒，所以暂时没有使用它的其他插件和配置。大家有兴趣可以看官网。
##Tagbar
和TagList差不多。为什么不使用TagList。因为貌似不更新了。而且Tagbar对面向对象的语言支持更友好些。
# 查找
##ctrlp
是对文件进行模糊的查找，如果你的project目录结构复杂，或者你正在阅读一个较大的项目的话，那么ctrlp可以帮你快速的定位到你想要文件而不必在终端不断的cd、ls。
###使用方式

开启搜索：ctrl+p
开户搜索后的操作如下
* F5       刷新
* Ctrl+F|Ctrl+B  切换模式。
搜索缓冲区的文件，标记是“buffers”
<img src="http://images0.cnblogs.com/blog2015/762312/201508/270929501097705.png" width="100%"/>
搜索最近打开的文件，标记是“mru files”
<img src="http://images0.cnblogs.com/blog2015/762312/201508/270931457652106.png" width="100%"/>
搜索文件，标记是“files”
<img src="http://images0.cnblogs.com/blog2015/762312/201508/270932136097412.png" width="100%"/>
* Ctrl+D      切换只搜索文件名还是搜索路径
搜索的时候包括路径
<img src="http://images0.cnblogs.com/blog2015/762312/201508/270921134847506.png" width="100%"/>
搜索的时候只搜索文件，此时有一个“by fname”的标识
<img src="http://images0.cnblogs.com/blog2015/762312/201508/270921213288369.png" width="100%"/>
* Ctrl+r      切换搜索模式。普通搜索和正则搜索
正则搜索，此时有一个“regex”的标记，可以使用正则匹配。
<img src="http://images0.cnblogs.com/blog2015/762312/201508/270928091254087.png" width="100%"/>
* Ctrl+x 在当前窗口水平分屏打开文件
* Ctrl+v 同上, 垂直分屏
* Ctrl+o 打开文件，具体方式可以选择。
* Ctrl+n|Ctrl+p 搜索的历史记录
* Ctrl+z 标记多个文件，然后可以使用Ctrl+o打开它们

上面有各种各样的模式。可以混合着使用，感觉太给力了。
<img src="http://images0.cnblogs.com/blog2015/762312/201508/270935260159526.png" width="100%"/>
##EasyGrep
暂时没有找到比较好的文本搜索。如果有找到再同步更新。不过有总比没有强。
Vim是内置支持Grep的，Vim7.3更是更新了Grep的引擎，在Vim内Grep的速度更快了。但是Vim中的Grep一样不容易掌握，还好有很多简化Grep的插件可以用，包括grep的变种ack，这其中使用起来最方便的，最人性化的要数EasyGrep了。
1. 可视化的配置界面，可以让你很方便设置搜索路径，配备模式，递归模式等等。
2. 可以直接搜索当前光标下的单词，你不用再手动输入命令了。
3. 可以全局查找并替换，这在代码重构的时候特别有用，虽然这是IDE的基本功能，但是在Vim下我还没有看到那个插件做到EasyGrep这么好。用户可以选择是否替换当前匹配项，发现做错了，一个命令就可以取消所有的替换。

###使用方法
下面的"\"指的是<Leader>键。大家如果有兴趣也可以自行修改。在.vimrc里添加`let mapleader=',' `，然后就可以使用','当作<Leader>键了。
* \vv  在文件中搜索当前光标下的单词, :Grep word将搜索"word", 如果加叹号:Grep !word表示全词匹配的方式搜索, Grep也可以带参数, 比如:Grep -ir word, r表示递归目录. i表示不区分大小写.
* \vV  全词匹配搜索, 同:Grep !word;
* \va  与vv相似, 搜索结果append在上次搜索结果之后;
* \vA  与vV相似, 搜索结果append在上次搜索结果之后;
* \vr  替换;
* \vo  打开选项菜单;可以选择匹配。里面有很多选项，比较重要的是r(递归)，i(忽略大小写)

###有待解决的问题
还有几个问题不是很舒服，还在找解决办法
* 怎么像ctrlp那样舒服的打开窗口
* 怎么一次性还原所有替换过的文本
* 怎么更快捷的切换查找目录 

# 自动提示
##supertab
SuperTab使键入Tab键时具有上下文提示及补全功能
##AutoComplPop
装完，啥也不需要做。输入2个以上的字符后就会有提示了。不需要像以前那样还得按键才有提示。结合上面的supertab，这酸爽~~~。当然原来的自动补全的操作还是可以继续使用的。比如Ctrl+X,Ctrl+L等。
# 娱乐
##vim-matrix-screensaver
安装后输入:Matrix。然后就enjoy。
<img src="http://images0.cnblogs.com/blog2015/762312/201508/261621119372290.png" width="100%" />

#配置文件
对应的.vimrc的配置
```
"===>>>插件配置
"开始页面
Bundle 'mhinz/vim-startify'
"窗口
Bundle 'scrooloose/nerdtree'
Bundle 'bling/vim-airline'
Bundle 'majutsushi/tagbar'
"配色
Bundle 'tomasr/molokai'
Bundle 'altercation/vim-colors-solarized'
"查找文件
Bundle 'kien/ctrlp.vim'
"查找文本
Bundle 'vim-scripts/EasyGrep'
"自动提示
Bundle 'vim-scripts/AutoComplPop'
Bundle 'ervandew/supertab'
"娱乐
Bundle 'uguu-org/vim-matrix-screensaver'

"===>>>插件设置配置
"===>>>Startify配置
" 设置栏目排序。成对出现，一个标题，一个栏目名。
let g:startify_list_order = [
            \ ['   These are my bookmarks:'],
            \ 'bookmarks',
            \ ['   My most recently used files'],
            \ 'files',
            \ ['   My most recently used files in the current directory:'],
            \ 'dir',
            \ ['   These are my session和s:'],
            \ 'sessions',
            \]
"设置书签，一般都设置常用文件。像这里设置的是配置文件，因为我喜欢经常倒腾这些东西。也可以设置wiki文件页面。
let g:startify_bookmarks            = [
            \ '$VIM/_vimrc'
            \]

" 起始页显示的列表长度
let g:startify_files_number = 5
" 个性化头部信息定义。如果想定义尾部可以使用startify_custom_footer
let g:startify_custom_header = [
            \ '                                 ________  __ __        ',
            \ '            __                  /\_____  \/\ \\ \       ',
            \ '    __  __ /\_\    ___ ___      \/___//''/''\ \ \\ \    ',
            \ '   /\ \/\ \\/\ \ /'' __` __`\        /'' /''  \ \ \\ \_ ',
            \ '   \ \ \_/ |\ \ \/\ \/\ \/\ \      /'' /''__  \ \__ ,__\',
            \ '    \ \___/  \ \_\ \_\ \_\ \_\    /\_/ /\_\  \/_/\_\_/  ',
            \ '     \/__/    \/_/\/_/\/_/\/_/    \//  \/_/     \/_/    ',
	    \ '                                                        ',
	    \ '                                       Zhuang Junxiang  ',
	    \ '                                                        ',
	    \ '               1.01 ^ 365 = 37.78                       ',
	    \ '               0.99 ^ 365 =  0.02                       ',
            \ '',
            \ '',
            \ ]
" 设置快捷键
map <F2> :Startify<CR>

"===>>>NerdTree配置
" 设置快捷键
map <F3> :NERDTreeMirror<CR>
map <F3> :NERDTreeToggle<CR>

"===>>>Tagbar配置
" 设置快捷键
nmap <F7> :TagbarToggle<CR>


```
******

为什么不装winmanager和minibufexpl。因为个人习惯一般喜欢让编辑的窗口充满，所以不太愿意切分，如果有需要的时候才调用出来。minibufexpl，一般不会有同时开多个buffer的使用习惯。大家，如果感兴趣可以安装一下。]]></description></item><item><title>克服弱点，愈发完美-自我篇——《人性的弱点》读后感</title><link>http://www.cnblogs.com/ansn001/archive/2015/08/25/4756472.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Tue, 25 Aug 2015 01:00:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/08/25/4756472.html</guid><description><![CDATA[# 为什么要读这本书
前段时间刚拜读完《把时间当作朋友》，感觉确实很多东西是需要积累的，不是简简单单的归为天性。刚好这将近一年的时候内自己的状态不是很舒服。感觉自己为人处事非常的硬。很多情况下，和别人沟通并不能真正达到自己想要的目的，让自己和别人都会有淡淡的忧伤哈。

我觉得有一句话很应景：“如果你想真的做想一件事，整个宇宙都会支持你。”特别想解决这个问题，而《人性的弱点》就出现在我的前面。也没有刻意去寻找，刚好在收拾杂物的时候，从我老婆的书堆里随意抽了一本。就这么一随意，一下子就被它吸引了，心里强烈的就觉得它能解决我的问题。

我最近一直在努力的积累一个习惯：在读任何作品（书、视频、网文等）之前，都想一想为什么我要读它。我静坐在那思考了好多个早上，才隐隐约约理清了一个目的：进一步认清自己的问题或者说是弱点，克服它们，让自己更平和些，让自己更开心一些。当然，也许随着时间和认识的变化，这个目的会不断的调整。

所以，读书都是为了解决一个或者多个（最好是一个）真实存在的问题。这个问题有可能是具体有可能是很泛，最好越具体越好。
# 从这本书想得到什么
我想，我不是为了看书而看书。我也不想，看完后，当时觉得很有道理，然后过了段时间验证自己在做无用功。我想把世界性的知识变成我自己的知识或者是习惯。
所以从这本书，我想得到的是：
* 对人性的一些思考，因为我从没有在这方面认真思考过
* 列出几个（最多不超过5个）能改变我生活，可执行的建议。然后我将会陆续用时间和行动去验证它们是否适合我。然后不断的调整，直到变成一种习惯，不用再花时间刻意去记忆。就像《一万小时天才》里说的精深练习。

>>上面的两个维度，是我以后看所有作品的大前提。在决定要拜读一个作品，我都会努力思考这两个维度。解决什么问题！要怎么做才能解决这些问题
# 关于人性弱点理解
个人觉得这本书的名字起得非常贴切。因为几乎每个人一开始都会有这些弱点。只是随着每个人的成长，这些弱点或强或弱，或多或少罢了。

什么是个性的弱点呢？我的理解是：每个人只关心自己的事；每个人希望被人认可（或者说有想成为大人物的愿意）；每个人都不希望在别人前面表现出不好的任何东西，所以不愿意被批评等等。

同样的人性弱点，在用于自己和用于别人的时候有可能是完全不同。比如：对比批评，用于别人，我们要尽量去避免;用于自己，要勇于让别人批评，并且从中心平气和。所以，这两里有两个维度：我们怎么应对自己的人性弱点;我们怎么应对别人的人性弱点。我现在的理解，可以简单这么描述：对于自己要坦然、客观，对于别人要真诚、自然。

所有的资源交换都是对等的。为什么要提这么一个观点呢？主要是让自己不要浪费时间去纠结很多没有意义的诉求上面。当然前提是：大家都存在人性的弱点。如果，我们想要一个人的友谊，那我们必须克服自己的弱点，迎合对方的弱点，这是一个交换，而且客观是对等的，不管你愿不愿意接受。所以，如果你既想满足自己的弱点，又想多要对方的友谊，那几乎是不可能的事。所以同样的弱点，放在自己身上是克服，放在别人身上是迎合。假设，如果你不想从任何上身体获得任何东西，其实你没必要去迎合别人。

你永远改变不了别人。因为人性的弱点告诉我们，每个人只对自己的事感兴趣。所以我们能做的，只是改变自己。

事情本身是客观存在的，不会因为任何人改变。而我们的态度只会决定或者影响我们自己。所以，不管怎样，都以正向、乐观的态度去对待事物。这样才能让自己最大程度收益。

所以，我们只有客观、正向的克服自己的“人性的弱点”，然后去迎合别人的“人性的弱点”，通过等价的交换，以最小的成本来获得最大的资源。

# 需要实践的建议
这些弱点有可能需要一系列的行动才能完成。其实就是不断的实践和说服自己。
## 只为今天，我要很快乐
大部分人只要下定决心都会很快乐。每天多想想那些不用对比就可以很开心的事。个人建议不要对比，越对比越累。
* 想想自己的漂亮的老婆和萌萌达的儿子。
* 想想自己越来越完善的知识体系
* 想想自己越来越有能力去实现自己想要做的事
* 想想现在的所有一切只会让自己变得更优秀

## 只为今天，我要爱护我的身体
越来越觉得或者说懂得了身体的重要性，其他的什么都是假的。现在就开始行动！！
* 每天早上6点起床。
* 每天晚饭少食。
* 每天最多间隔一个半小时起来活动一下。
* 每周十公里慢跑。奥森2圈。

## 消除忧虑
纯粹的忧虑是最大的时间杀手。不但于事无补，甚至还有可能把自己给逼疯。
1. 分析忧虑的原因。往往忧虑90%的原因是对事情的不清楚。如果能分析清楚原因，忧虑至少能瞬间少一半
2. 写出来自己能做的所有可能方案。一定要写出来，在脑子里的东西不可见也更不可靠。
3. 取最优。选出上面最好的解决方案。
4. 预演最坏的结果。先想一想最优的解决方案的最坏结果，然后接收它，提前有一个心理准备。
5. 努力让结果变得越来越好。
6. 换一个方向。如果这样还是不能消除，有可能需要的是换一个思考方向。
7. 放任之。如果怎么都解决不了。不妨放任之，80%以上的事没有我们想象中的那么可怕。可以尝试把所有的事都放慢半拍。放任之，把时间和精力去解决真正能解决的问题上。

## 经常胡思乱想，去运动
与其让脑子搞得整个人不舒服。不如去运动，让身体健康起来。人真的累的时候，是很安静的。胡思乱想的人，一般都是有太多空闲时间。可以跑步，可以拳击，可以平板支撑等等。
当然这里说的是胡思乱想，而不是说正向的思考。当然每个人对胡思乱想的定义范围可能不一样。那不妨尝试描述一下：长时间只空想，不能把空想变成实际的行动或者是习惯，暂时称为胡思乱想。


# 需要加强的建议
这里的建议，是我以前也有在实践，不过实践的不好，或者说我希望做得更好的地方。
## 不要为打翻的牛奶而伤心
不去纠结任何解决不了的事。需要增强分析过程
1. 分析这事是不是还能挽回。如果还能挽回就努力去解决。
2. 如果怎么做都挽回不了。忘记它
3. 做好下一件事

怎么做好下一件事呢？
1. 记录下来，放到经常可以看到的地方，时不时提醒自己。必须记录下来，脑袋里的东西再鲜明，时间也会冲淡。
1. 静下来分析一下，怎么避免类似的问题，预防再次出现，做好下一件事。自怨自艾是在浪费时间。人总是会有痛苦遗忘的弱点。

## 和自己的缺点做斗争
修改缺点，不是痛苦的事，是让自己更升华的事。这是一个不断完善自己的过程，应该happy哈。
1. 在分析不了是否是优点时：记录别人说的自己的缺点
1. 自己经常反思，自己有哪些缺点
1. 哪些缺点和自己的人生价值观是相反的
1. 列出来实践修改之。可以在脑子里想象一下不修改这些缺点的后果，建议时间间隔拉长一些，比如加一个时间限定5年或者10年或者一辈子。我们经常对于自己的缺点，总是想轻易的放过。甚至会用一些冠冕堂皇的借口，比如我能力不够，运气不好，我不感兴趣。
1. 现在就开始实践

现在比较严重的缺点，也是一直在努力改进的缺点：
1. 喜欢批评别人
1. 喜欢拿自己的标准去衡量别人
1. 喜欢把自己的想法当作道理。
1. 赞美的比较少
1. 喜欢自己一直不断的说话
1. 喜欢打断别人说话

## 划分事情的优先级
1. 只要不是马上必须解决，不解决就会死人的，都要划分优先级。
1. 不解决就会死人的，也应该冷静下来分析一下怎么解决，不然会事与愿违
1. 判断问题的主次，有序地加以解决]]></description></item><item><title>菜鸟vimer成长记——第4.0章、Vim插件管理利器-Vundle</title><link>http://www.cnblogs.com/ansn001/archive/2015/08/24/4747015.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 24 Aug 2015 01:39:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/08/24/4747015.html</guid><description><![CDATA[# 定义
Vundle是vim bunler和简称，它是一个vim插件管理器。
Vim本身缺乏对插件的有效管理，安装插件并配置.vimrc文件非常不便。gmarik受到Ruby的bunler的启发，开发了vundle这个vim插件，可以将插件分到不同的目录管理。
Vundle基于Git架构，每一个插件都是一个项目的Repository，通过Vundle可以用简单的指令，管理插件的生命周期。这样，只要有一份.vimrc，到哪都可以使用原有的vim插件了。当然基本前提是：系统已经要有git。

# 安装
具体怎么安装，有很多文章，所以这里不细讲了，有兴趣可以参见 [官方文档](https://github.com/VundleVim/Vundle.vim)
大体的步骤：
1. 确定系统有git。如果没有，先提前安装git
2. 通过git clone vundle
3. 添加.vimrc文件vundle相关的配置

然后就可以通过vundle相关命令来管理vim插件的生命周期

# 插件类型
这里指的是vundle定义的类型，并不代表的是vim自然类型。vim自然类型暂时不深入，如果有兴趣可以参见[常用插件](http://www.cnblogs.com/chijianqiang/archive/2012/11/06/vim-3.html)
## Github
说明：引入Github的插件
语法：用户/仓库 => 相当于：`https://github.com/用户/仓库`
`
Plugin 'gmarik/Vundle.vim' =>'https://github.com/gmarik/Vundle.vim'
`
## Vim scripts
说明：引入'https://github.com/vim-scripts'下面的插件
语法：单词(不带"/"的)  => 相当于：`https://github.com/vim-scripts/单词`
`Plugin 'ctrlp.vim' => 'https://github.com/vim-scripts/ctrlp.vim'`
## 非Github
说明：这里需要的是全路径，引用的是非Github的插件
` Plugin 'git://git.wincent.com/command-t.git' `
这种类型暂时没使用过
## 本地
说明：这里需要的是全路径，引用的是本地的插件
` Plugin 'file:///path/from/root/to/plugin'`
这种类型暂时没使用过

# 生命周期
这里指的是管理vim插件的生命周期。我比较喜欢用“生命周期”这个词。因为这样，脑子里能很方便的记忆着这一系列的命令以及场景。
语法如下：
<pre>
:BundleList             列举列表(也就是.vimrc和已经安装的插件)中配置的所有插件
:BundleInstall          安装列表中的全部插件
:BundleInstall!         更新列表中的全部插件
:BundleSearch    	查找foo插件
:BundleSearch!   	刷新foo插件缓存
:BundleClean           	清除列表中没有的插件
:BundleClean!          	清除列表中没有的插件
</pre>

注意事项:
1. 后面的所有命令都可以加上[name1 name2 ...]参数。如果有加，就指的是针对管理这些指定插件的生命周期。所以不在一一赘述
2. 在输入命令时，可以使用Tab键|Ctrl+d来提示

## 列举
语法：PluginList
列举插件列表，这里面包括两类：
1. .vimrc文件里配置的插件
2. 已经安装，但是没有在.vimrc文件里体现的插件。比如直接通过PluginInstall {name}直接安装，如果已经安装成功，虽然.vimrc文件里没有，但是依然会在PluginList里显示
注意事项：
1. 要把PluginList的所有插件同步到.vimrc配置文件。这样下一次就可以直接安装了。

## 安装
语法：PluginInstall 
安装BundleList里的所有插件
注意事项：
1. PluginInstall后面如果加"!"，此时表示的是更新而不是安装，相当于下面的PluginUpdate

## 更新
语法：PluginUpdate 
更新BundleList里的所有插件
## 查找
语法： PluginSearch 
这里查询的是Vim scripts类型插件。其他插件都不在可搜索范围
这里的搜索，支持前后模糊，但是不支持正则
查找到后可以直接对插件进行生命周期的管理。
但是如果此时安装的插件，并不会在.vimrc配置文件里面，所以要同步BundleList列表到.vimrc
## 清除
语法： PluginClean
清除没有用的插件

# PS
## 过时命令
下面两类命令现在都可以使用，不过建议使用pluginXxxx系列。

<pre>
过时命令  	  |	   新命令
Bundle            | Plugin
BundleInstall(!)  | PluginInstall(!), VundleInstall(!)
BundleUpdate      | PluginUpdate, VundleUpdate
BundleSearch(!)   | PluginSearch(!), VundleSearch(!)
BundleClean       | PluginClean(!), VundleClean(!)
BundleList        | PluginList
</pre>

## 有效位置
可以通过.vimrc文件里设置需要添加的插件，但是这些插件的位置需要注意一下。
>
"所有需要添加的插件都必须放在这行之后
call vundle#begin()
"...其他设置
Plugin 'VundleVim/Vundle.vim'
"...其他设置
"所有需要添加的插件都必须放在这行之前
call vundle#end() 


# 参考资源
1. [Vundle官网](https://github.com/VundleVim/Vundle.vim)
2. [Windows下安装Vim插件管理Vundle](http://blog.csdn.net/zhuxiaoyang2000/article/details/8636472)]]></description></item><item><title>菜鸟vimer成长记——第3章、文件</title><link>http://www.cnblogs.com/ansn001/archive/2015/08/17/4727511.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 17 Aug 2015 02:10:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/08/17/4727511.html</guid><description><![CDATA[<p><span style="line-height: 1.5;">　　上一章一直在讲的是vim的文本的操作，本章主要讲的是vim的文件操作。</span></p>
<p><span style="line-height: 1.5;">　　本章的有些概念和传统的文本编辑器也不尽相同。所以需要注意概念或者切切说是思维习惯的区别。</span></p>
<p>　　vim 允许在一个编辑会话中编辑多个文件，我们既可以每次显示一个文件，也可以把工作区分成若干个分割窗口或标签页，每个窗口或标签页包含一个独立的缓冲区。</p>
<h1>概念</h1>
<p>　　在开始学习之前，有必要先弄清楚几个重要的概念：文件、缓冲区、窗口、标签页。以及，他们之间的关系是什么</p>
<h2>文件</h2>
<p>　　这里的文件，指的是存储在磁盘上的文件。在工作过程中，我们通常会说&ldquo;我们正在编辑一个文件&rdquo;，但真实情况并不是这样，vim编辑的并不是文件。</p>
<h2>缓冲区</h2>
<p>　　那vim编辑的是什么呢？vim编辑的是文件在内存中的映像，也就是 Vim 术语中的&ldquo;缓冲区&rdquo;。</p>
<p>　　当 Vim 打开一个文件时，该文件的内容被读入一个具有相同名字的缓冲区。刚开始，缓冲区的内容和文件的内容完全相同，但当我们对缓冲区做出修改时，二者的内容就会出现差别。如果我们决定保留这些修改，就可以再把缓冲区的内容写回到文件里。所以其实我们在vim操作的文本都是针对于缓冲区。</p>
<p>　　编辑文件的步骤：</p>
<ol>
<li>从文件读到缓冲区</li>
<li>修改缓冲区的文本。此时原始文件里的文本不会做任何的变化。</li>
<li>把缓冲区写到文件。此时原始文件的文本才重新又和缓冲区一致。</li>
</ol>
<h2>窗口</h2>
<p>　　窗口是缓冲区的显示区域。决定要把哪个缓冲区的内容显示在这个区域。</p>
<p>　　我们既可以打开多个窗口，在这些窗口中显示同一个缓冲区，也可以在每个窗口里载入不同的缓冲区。</p>
<p>　　所有的窗口共享同一个缓冲区列表，即在内存的所有缓冲区。</p>
<p>　　缓冲区有以下几个状态：</p>
<ul>
<li>活动状态：处于这个状态的缓冲区被显示在窗口上。如果一个文件对应的缓冲区被载入内存，一般处于这个状态。</li>
<li>隐藏状态：处于这个状态的缓冲区不会被显示在窗口上。</li>
<li>非活动状态：处于这个状态的缓冲区不会被显示在窗口上。并且什么内容也没有。？？？具体什么情况，我也还没弄清楚。</li>
</ul>
<h2>标签页</h2>
<p>　　一个标签页是一系列窗口的集合或者说容器。这里的标签页和其他编辑器的还不太一样。其他的编辑器一个标签页对应的是一个文件对应的缓冲。但是在vim里，一个标签页，更多时候像一个工作空间。</p>
<p>　　假设我们正在处理某个工程中的文件，并且已经把工作区分成了几个窗口。然后，突然接到一项紧急任务，我们不得不马上切换工作内容。我们不想在当前标签页里打开新文件，因为这会把我们精心布置的工作区弄乱。此时，我们可以新创一个标签页，并在此标签页中工作。当我们准备继续做原来的工作时，只需切回原来的标签页即可，所有的窗口都保持着我们离开时的模样。</p>
<h1>文件</h1>
<p>　　虽然这里标题叫文件，但是这里面讲的基本上的缓冲区，也稍微涉及到窗口等其他概念。下面会围绕着文件操作的生命周期来展开描述。</p>
<p>　　注意事项</p>
<ul>
<li>所有的操作基本都可以强制操作。统一规则是： :动作!。在动作后面加一个"！"。</li>
</ul>
<h2>打开</h2>
<p>　　打开文件，指的是把硬盘上的文件的文本读入到内存里，生成一个缓冲区，这个缓冲区的名字和文件名一致。</p>
<p>　　打开的方式：</p>
<ul>
<li>如果还没有打开vim。可以通过"vim file1 file2 ..."直接打开</li>
<li>如果已经打开vim，想在vim里直接打开文件，可以使用:edit来完成。</li>
<li>如果已经打开vim，不知道具体的文件路径，还可以通过:find来完成。</li>
</ul>
<p>　　这里有需要注意的点是：打开文件的路径。</p>
<p>　　允许通过文件的绝对路径或相对路径来打开文件。绝对路径好理解，就不赘述了。下面主要说一下相对路径。</p>
<p>　　在打开文件，需要输入文件相对路径时结合自动补全命令（Tab和&lt;C-d&gt;）很爽。</p>
<h3>相对于当前工作目录</h3>
<p>　　查看当前工作目录：pwd</p>
<p>　　切换当前工作目录：cd</p>
<p>　　注意事项</p>
<ul>
<li>cd的时候有一个特殊符号："-"，表示上一次的目录 。使用:cd - 就可以切回上一个目录。</li>
</ul>
<h3>相对于活动文件目录</h3>
<p>　　有的时候，我们在编辑一个文件A。这个文件A并不在当前的工作目录下。此时，我们又想编辑另一个文件B，这个文件B和文件A在同一个目录。</p>
<p>　　一种做法是输入从工作目录开始的路径，直到抵达该文件，然而这似乎有点儿舍近求远。想打开的文件和活动缓冲区中的文件在同一个目录里，如果能用活动缓冲区作参考点岂不是更理想吗</p>
<p>　　% 符号代表活动缓冲区的完整文件路径。%:h去除文件名，但保留路径中的其他部分（这里当前于目录的路径）。</p>
<blockquote>
<p>:e %:h&lt;Tab&gt;Ma&lt;Tab&gt;</p>
<p>#输入%:h&lt;Tab&gt;会被展开为当前文件所在目录的路径<span style="line-height: 1.5;">　</span></p>
</blockquote>
<h3>通过查找打开文件</h3>
<p>　　:find 命令允许我们通过文件名打开一个文件，但无需输入该文件的完整路径。</p>
<p>　　只要给出了一个文件的完整文件路径，我们始终可以用:edit 命令打开此文件。然而，如果我们工作的工程中包含了多级嵌套目录呢？每次打开文件都得输入完整路径，这着实令人生厌。这就是为什么要引入:find 命令的原因。要想利用此功能，我们首先要配置&lsquo;path&rsquo; 选项。</p>
<p>　　要想利用此功能，我们首先要配置&lsquo;path&rsquo; 选项。:set path+={path}</p>
<p>　　{path}支持通配。</p>
<div class="cnblogs_code">
<pre>:set path+=.<span style="color: #008000;">/*</span><span style="color: #008000;">*

# ** 通配符会匹配当前目录下的所有子目录
# * 和 ** 在'path' 设置中的处理与前文略有不同
# 更多详情查看:h file-searching</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="line-height: 1.5;">　　输入文件名后，然后按一下&lt;Tab&gt; 键，Vim 就会在命令行上展开第一</span>个匹配文件的完整文件路径；再按一次&lt;Tab&gt; 键，又会换成下一个匹配文件的完整文件路径</p>
<h2>列表</h2>
<p>　　显示缓冲区列表。语法： :files|:buffers|:ls ，这三个都可以。不过我一般比较懒，喜欢少打几个字，一般使用:ls</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201508/141056571924690.png" alt="" /></p>
<p>　　请注意状态区，就是截图的部分。这里面有4个位置：第一位（u），第二位(#,%)，第三位(h,a)，第四位(+)。</p>
<ol>
<li>第一位：这个一般是没有的。如果有的话是u，表示用于显示帮助文档。 一般可以设置没有这个状态，通过:setlocal nobuflisted设置就可以</li>
<li>第二位：%表示的是当前活动（窗口显示）的缓冲区，#表示的是上一个活动的缓冲区。</li>
<li>第三位：缓冲区的状态。上面说过了。a表示激活状态，h表示隐藏状态</li>
<li>第四位：表示当前文件的状态<ol>
<li>- ：不允许修改</li>
<li>=：只读</li>
<li>+：已经被修改过</li>
<li>x ：载入的时候错误</li>
</ol></li>
</ol>
<h2>切换</h2>
<p>　　窗口只显示一个缓冲区，那如何在不同的缓冲区切换呢？</p>
<p>　　在cmd-line模式下的切换语法</p>
<table border="0">
<tbody>
<tr>
<td>命令</td>
<td>用途</td>
</tr>
<tr>
<td>:bn</td>
<td>切换到下一个缓冲区</td>
</tr>
<tr>
<td>:bp</td>
<td>切换到上一个缓冲区</td>
</tr>
<tr>
<td>:b{buffername}</td>
<td>切换名为{buffername}的缓冲区</td>
</tr>
<tr>
<td>:b{n}</td>
<td>切换到编写为n的缓冲区</td>
</tr>
<tr>
<td>:bfirst</td>
<td>切换到第一个缓冲区</td>
</tr>
<tr>
<td>:blast</td>
<td>切换到最后一个缓冲区</td>
</tr>
<tr>
<td>:b#</td>
<td>切换到上一个显示的缓冲区</td>
</tr>
</tbody>
</table>
<p>&nbsp;　　可以通过映射更快捷的来切换。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201508/171007051443071.png" alt="" width="560" height="301" /></p>
<h2 class="not">保存</h2>
<p>　　把缓冲区的文本写入文件中。需要注意的是，只要没保存之前，所有的操作就是在缓冲区操作的。对原始的文件根本没有任何影响。</p>
<p>　　这个语法在cmd-line模式的动作里已经说过了。就不在这里说了。对应的是:w。</p>
<h2 class="not">删除</h2>
<p>　　</p>
<p>删除一个缓冲区并不会影响缓冲区所关联的文件，而只是简单地把该文件<br />在内存中的映像删掉</p>
<p>　　语法：bd {buffername}</p>
<h2 class="not">退出</h2>
<p>　　其实退出的是窗口</p>
<p>　　语法:q</p>
<h1>窗口</h1>
<h2>分隔</h2>
<p>　　有很多种分隔方式，每种略微不一样</p>
<h3>通过vim分隔</h3>
<p>　　在还没打开文件之前，想就分隔，可以使用。</p>
<p>　　语法：vim -(o|O) file1 file2 ...</p>
<ul>
<li>o(小写o)代表的是横向分屏</li>
<li>O(大写o)代表的是竖向分屏。</li>






</ul>
<h3>通过快捷键</h3>
<p>　　如果想对当前窗口分屏，可以直接使用快捷键。</p>
<ul>
<li>&lt;C-w&gt;s |&lt;C-w&gt;&lt;C-s&gt; &nbsp;表示的是横向分屏</li>
<li>&lt;C-w&gt;v |&lt;C-w&gt;&lt;C-v&gt; &nbsp;表示的是竖向分屏</li>






</ul>
<h3>通过ex命令</h3>
<p>　　如果在当前窗口，想对其他文件分屏，可以使用ex命令</p>
<ul>
<li>:vs file &nbsp; 表示的是竖向分屏</li>
<li>:sp file &nbsp; 表示的是横向分屏</li>






</ul>
<p>　　注意事项</p>
<ul>
<li>如果不跟 file ，则相当于对当前文件分屏</li>






</ul>
<h2>设置大小</h2>
<p>　　一般是在分屏的情况下，有些屏想当作主屏，可以把这个窗口设置显示大些。</p>
<table border="0">
<tbody>
<tr>
<td>操作</td>
<td>用途</td>






</tr>
<tr>
<td>z{height}</td>
<td>设置窗口大小。一般比较喜欢这个用法，操作起来快。</td>






</tr>
<tr>
<td>&lt;C-w&gt;-</td>
<td>减少窗口大小</td>






</tr>
<tr>
<td>&lt;C-w&gt;+</td>
<td>增加窗口大小</td>






</tr>
<tr>
<td>&lt;C-w&gt;=</td>
<td>所有窗口等宽、等高</td>






</tr>
<tr>
<td>&lt;C-w&gt;_</td>
<td>最大化活动窗口的宽度</td>






</tr>
<tr>
<td>&lt;C-w&gt;|</td>
<td>最大化活动窗口的高度</td>






</tr>






</tbody>






</table>
<p>　　更多详细可以参见 :h window-resize</p>
<h2>移动</h2>
<p>　　移动指的是移动光标位置</p>
<table border="0">
<tbody>
<tr>
<td>操作</td>
<td>用途</td>






</tr>
<tr>
<td>&lt;C-w&gt;h</td>
<td>光标移动到左边的窗口</td>






</tr>
<tr>
<td>&lt;C-w&gt;j</td>
<td>光标移动到下面的窗口</td>






</tr>
<tr>
<td>&lt;C-w&gt;k</td>
<td>光标移动到上面的窗口</td>






</tr>
<tr>
<td>&lt;C-w&gt;l</td>
<td>光标移动到右边的窗口</td>






</tr>
<tr>
<td>&lt;C-w&gt;t</td>
<td>光标移动到最顶端的窗口</td>






</tr>
<tr>
<td>&lt;C-w&gt;b</td>
<td>光标移动到最底端的窗口</td>






</tr>
<tr>
<td>&lt;C-w&gt;w|&lt;C-w&gt;&lt;C-w&gt;</td>
<td>光标在窗口中循环移动</td>






</tr>






</tbody>






</table>
<p>&nbsp;</p>
<h2>布局</h2>
<p>　　想移动窗口在标签页中显示的位置</p>
<table border="0">
<tbody>
<tr>
<td>操作</td>
<td>用途</td>






</tr>
<tr>
<td>&lt;C-w&gt;&lt;S-h&gt;</td>
<td>把当前窗口移动到最左侧</td>






</tr>
<tr>
<td>&lt;C-w&gt;&lt;S-j&gt;</td>
<td>把当前窗口移动到最下面</td>






</tr>
<tr>
<td>&lt;C-w&gt;&lt;S-k&gt;</td>
<td>把当前窗口移动到最上面</td>






</tr>
<tr>
<td>&lt;C-w&gt;&lt;S-l&gt;</td>
<td>把当前窗口移动到最右侧</td>






</tr>






</tbody>






</table>
<p>&nbsp;</p>
<h2 class="not">关闭</h2>
<p>　　关闭窗口，窗口显示的缓冲区还在内存中。关闭窗口有这几类</p>
<ul>
<li>关闭当前窗口 。语法： :q|:clo[se]</li>
<li>关闭其他窗口（除了当前窗口的当前标签页的其他窗口）。语法： :on[ly]</li>
<li>关闭当前标签页所有窗口。语法 :qall</li>






</ul>
<h1>标签页</h1>
<p>　　用 Vim 的标签页可以把工作分隔到不同的工作区。Vim 中的标签页更像是Linux 中的虚拟桌面，而不是像其他文本编辑器中的标签页。</p>
<p>　　在 Vim 中，标签页是可以容纳一系列窗口的容器（参见:h tabpage ）</p>
<p>　　Vim 的标签页与缓冲区并非一一对应的关系，相反，应该把标签页想成容纳一系列窗口的容器</p>
<hr />
<p>&nbsp;</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201508/141452305673565.png" alt="" width="673" height="164" /></p>
<hr />
<p>&nbsp;</p>
<h2 class="not">打开</h2>
<p><span style="line-height: 1.5;">　　用:tabedit {filename} 命令可以打开一个新的标签页， 如果省略了</span>{filename} 参数的话，那么 Vim 会创建一个新标签页，里面包含一个空缓冲区。</p>
<p>　　还有一种做法，如果当前标签页中包含了不止一个窗口，我们可以用&lt;C-w&gt;T 命令把当前窗口移到一个新标签页中（参见:h CTRL-W_T ）。</p>
<p>　　在任何命令打开一个窗口的Ex命令前端加一个":tab"，则会打开一个新的标签。特别是在使用帮助文档时特别好用。比如: tab h gt</p>
<h2>切换</h2>
<p>　　切换当前活动的标签页</p>
<table border="0">
<tbody>
<tr>
<td>Ex命令</td>
<td>普通模式命令</td>
<td>用途</td>






</tr>
<tr>
<td>:tabn {N}</td>
<td>{N}gt</td>
<td>切换到编号为{N}的标签页</td>






</tr>
<tr>
<td>:tabn</td>
<td>gt</td>
<td>切换到下一个标签页</td>






</tr>
<tr>
<td>:tabp</td>
<td>gT</td>
<td>切换到上一个标签页</td>






</tr>






</tbody>






</table>
<h2>重排</h2>
<p>　　重新排序标签页。</p>
<p>　　用:tabmove [N] 命令可以重新排列标签页。当[N] 为0 时，当前标签页会被移到开头；如果省略了[N]，当前标签页会被移到结尾。如果你的终端支持鼠标，或是你正在使用GVim，那么你也可以通过鼠标拖曳来进行重排操作。</p>
<h2 class="not">关闭</h2>
<p>　　关闭标签，只是关闭标签页下面显示的窗口。关闭标签页有这几类</p>
<ul>
<li>关闭当前标签页 。语法： :tabc[lose]</li>
<li>关闭其他标签页（除了当前标签页的当前标签页的其他标签页）。语法： :tabon[ly]</li>






</ul>
<p>　</p>
<p>&nbsp;</p>]]></description></item><item><title>菜鸟vimer成长记——目录</title><link>http://www.cnblogs.com/ansn001/archive/2015/08/13/4727319.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Thu, 13 Aug 2015 06:57:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/08/13/4727319.html</guid><description><![CDATA[<p><a id="cb_post_title_url" style="line-height: 1.5;" href="http://www.cnblogs.com/ansn001/p/4635978.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第0章、我眼中的vim学习</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4642209.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第1章、统一概念</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4646072.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第2.0章、模式初探</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4655073.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第2.1章、normal模式</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4680966.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第2.2章、visual模式</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4685307.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第2.3章、insert模式</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4704072.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第2.4章、cmd-line模式</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4727511.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第3章、文件</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4747015.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第4.0章、Vim插件管理利器-Vundle</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4760192.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第4.1章、通用插件</a></p>
<p><a id="cb_post_title_url" href="http://www.cnblogs.com/ansn001/p/4789461.html" target="_blank">菜鸟vimer成长记&mdash;&mdash;第4.2章、编程插件</a></p>
<p>菜鸟vimer成长记&mdash;&mdash;第5章、个性化（未更新）</p>]]></description></item><item><title>菜鸟vimer成长记——第2.4章、cmd-line模式</title><link>http://www.cnblogs.com/ansn001/archive/2015/08/10/4704072.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 10 Aug 2015 10:33:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/08/10/4704072.html</guid><description><![CDATA[<p>　　cmd-line模式又有3个类型：Ex 命令（ex commands）、查找模式（Search patterns）、Filter 命令（Filter commands）。本文主要重点的是Ex 命令和Search patterns。Filter 命令暂时用的场景比较少，如果有更适合的场景再补充。</p>
<h1>目的</h1>
<p>掌握cmd-line模式下常用操作的语法和概念</p>
<h1>Ex 命令简介</h1>
<p>　　初时，先有ed,ed为ex之父，ex为vi之父，而vi为vim之父。可见Ex 命令的重要性。</p>
<p>　　在Ex 命令影响范围广且距离远。对比normal模式的文本操作，它适合在本地（或者说可以通过快捷键一次到达）进行操作。</p>
<p>　　一般操作都是范围（{range}）+动作。</p>
<p>　　Vim 为几乎所有功能都提供了相应的Ex 命令。下面简要列举几个</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 300px;">命令</th><th>用途</th></tr>
<tr>
<td>:[range]delete [x]</td>
<td>删除指定范围内的行[到寄存器x 中]</td>
</tr>
<tr>
<td>:[range]yank [x]</td>
<td>复制指定范围的行[到寄存器x 中]</td>
</tr>
<tr>
<td>:[line]put [x]</td>
<td>在指定行后粘贴寄存器x 中的内容</td>
</tr>
<tr>
<td>:[range]copy {address}</td>
<td>把指定范围内的行拷贝到{address} 所指定的行之下</td>
</tr>
<tr>
<td>:[range]move {address}</td>
<td>把指定范围内的行移动到{address} 所指定的行之下</td>
</tr>
<tr>
<td>:[range]join</td>
<td>连接指定范围内的行</td>
</tr>
<tr>
<td>:[range]normal {commands}</td>
<td>对指定范围内的每一行执行普通模式命令{commands}</td>
</tr>
<tr>
<td>:[range]global/{pattern}/[cmd]</td>
<td>对指定范围内匹配{pattern}的所有行，在其上执行Ex 命令{cmd}</td>
</tr>
<tr>
<td>:[range]substitute/{pattern}/{string}/[flags]</td>
<td>把指定范围内出现{pattern}的地方替换为{string}</td>
</tr>
</tbody>
</table>
<p>　　概念：</p>
<ul>
<li>[range]指的是范围。下方会涉及到</li>
<li>[x] 表示的寄存器具名。即[a-zA-Z]</li>
<li>{address}表示的是地址。</li>
<li>{pattern}对应的是下面的模式</li>
<li>[cmd]表示动作</li>
<li>{string} 字符串</li>
<li>[flags] 标记</li>
<li>{commands}表示normal模式下的一系列操作</li>
</ul>
<p>　　想了解更多，参见:h ex-cmd-index。</p>
<h1>移动光标</h1>
<p>　　在cmd-line模式下怎样更快捷的移动光标。一般是为了更正输入的错误。</p>
<p>　　语法如下：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">命令</th><th>用途</th></tr>
<tr>
<td>Ctrl+B</td>
<td>移动到命令的末尾</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>移动到命令的行首</td>
</tr>
<tr>
<td>Ctrl+&lt;Left&gt;</td>
<td>向左移动一个单词</td>
</tr>
<tr>
<td>Ctrl+&lt;Right&gt;</td>
<td>向右移动一个单词</td>
</tr>
<tr>
<td>&lt;Left&gt;</td>
<td>向左移动一个字符</td>
</tr>
<tr>
<td>&lt;Right&gt;</td>
<td>向右移动一个字符</td>
</tr>
</tbody>
</table>
<h2 class="not">删除</h2>
<p>　　移动的时候，一般只使用Ctrl+B,Ctrl+E。如果此时输错了，之前在insert模式也说过了，最好的办法是删除重输。所以这里介绍一下删除的快捷键</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">命令</th><th>用途</th></tr>
<tr>
<td>Ctrl+U</td>
<td>删除到行首</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>删除一个单词</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2 class="not">快捷键映射</h2>
<p>　　如果还是更习惯移动光标，那可以把非主键区的按键映射成主键区的组合</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201508/101011341927261.png" alt="" width="722" height="139" /></p>
<p>　　这个设置，大家可以根据自己的习惯来设置。我一般只设置单词移动，然后如果输错了直接删除重输。</p>
<h1>历史记录</h1>
<p>　　查看命令的历史。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201508/101407378645413.png" alt="" width="454" height="357" /></p>
<p>　　查看历史记录的语法如下</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">命令</th><th>用途</th></tr>
<tr>
<td>Ctrl+P</td>
<td>上一条命令</td>
</tr>
<tr>
<td>Ctrl+N</td>
<td>下一条命令</td>
</tr>
</tbody>
</table>
<h2 class="not">命令窗口</h2>
<p>　　命令行窗口就像是一个常规的 Vim 缓冲区，只不过它的每行内容都对应着命令历史中的一个条目。我们可以用k 及j 键在历史中向前或向后移动（像另一个独立的操作窗口，可以使用正常的所有模式命令），也可以用 Vim 的查找功能查找某一行。在按下&lt;CR&gt; 键时，将会把当前行的内容当成Ex 命加以执行</p>
<p>　　开启命令窗口语法</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">命令</th><th>用途</th></tr>
<tr>
<td>q/</td>
<td>在normal模式打开查找命令历史的命令行窗口</td>
</tr>
<tr>
<td>q:</td>
<td>在normal模式打开 Ex 命令历史的命令行窗口</td>
</tr>
<tr>
<td>&lt;Ctrl-f&gt;</td>
<td>从cmd-line模式切换到命令行窗口</td>
</tr>
</tbody>
</table>
<p>　　例如</p>
<div class="cnblogs_code">
<pre><span># 假设我们正在写一个简单的Ruby 脚本，然后发现每做出一个修改时，都会执行
# 下面两条命令：
# :write<span>
# :!ruby %<span>
# 在接连执行了几次这两条命令后，我们意识到可以简化工作过程，把这两条命令
# 合为一条。这样，以后就可以从历史中选择该完整命令并再次执行：
# :write | !ruby %<span>
# 这些命令都已经在历史中了，所以我们不必从头输入整条命令。但要怎样才能把历史
# 中的两条记录合并成一条呢？

# 执行下面的步骤即可
q:
k
J(Shift+<span>j)
&lt;CR&gt;</span></span></span></span></span></pre>
</div>
<h1>自动补全</h1>
<p>　　补全的语法</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">命令</th><th>用途</th></tr>
<tr>
<td>tab</td>
<td>如同在shell 中一样，在命令行上也可以用&lt;Tab&gt; 键自动补全命令。</td>
</tr>
<tr>
<td>Shift+tab</td>
<td>要想反向遍历补全列表</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>命令会让Vim 显示可用的补全列表。这个在挺好用的。</td>
</tr>
<tr>
<td>Ctrl+A</td>
<td>补全所有匹配列表</td>
</tr>
<tr>
<td>ctrl+L</td>
<td>只有一个匹配的时候。暂时觉得用处不大</td>
</tr>
<tr>
<td>&lt;C-r&gt;&lt;C-w&gt;</td>
<td>把当前单词插入到命令行</td>
</tr>
<tr>
<td>&lt;C-r&gt;{register}</td>
<td>可以把寄存器的内容插入到命令行</td>
</tr>
</tbody>
</table>
<p>　　例如</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201508/101037029577782.png" alt="" width="795" height="324" /></p>
<h1>重复执行</h1>
<p>　　在normal模式重复上次的 Ex 命令非常简单，只需按@:。</p>
<p>　　注意事项</p>
<ul>
<li>
<p>&nbsp;: 寄存器总是保存着最后执行的命令行命令。在运行过一次@: 后，后面就可以用@@ 命令来重复它。</p>
</li>
</ul>
<h1>范围</h1>
<p>　　很多 Ex 命令可以用[range] 指定要操作的范围。我们可以用行号、位置标记或是查找模式来指定范围的开始位置及结束位置。</p>
<p>　　在定义一个[range]时，它总是代表一系列连续行，不过:global 命令也可以在一系列非连续行上执行Ex 命令</p>
<h2 class="not">用地址指定范围</h2>
<p>　　指的就是上面的{address}。</p>
<p>　　地址类型如下</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">符号</th><th>地址</th></tr>
<tr>
<td>0</td>
<td>虚拟行，位于文件第一行上方。</td>
</tr>
<tr>
<td>n</td>
<td>文件的第n行</td>
</tr>
<tr>
<td>$</td>
<td>文件的最后一行</td>
</tr>
<tr>
<td>.</td>
<td>光标所在的那一行</td>
</tr>
<tr>
<td>'m</td>
<td>包含位置标记m 的行</td>
</tr>
<tr>
<td>%</td>
<td>整个文件（:1,$ 的简写形式）</td>
</tr>
</tbody>
</table>
<p>　　注意事项：</p>
<ul>
<li>
<p>第0 行在文件中并不真实存在，但它作为一个地址，在某些特定场景下会很有用处。特别是，在把指定范围内的行复制或移动到文件开头时，可以用它做:copy{address} 及:move {address} 命令的最后一个参数。</p>
</li>
<li>很多情况下不写[range]情况是默认当前行</li>
<li>:{start},{end}表示一个更广的范围。其中{start}和{end}都表示{address}。比如:.,$表示当前行到文件尾。</li>
</ul>
<p>　　特殊场景：</p>
<ul>
<li><span style="line-height: 1.5;">如果输入一条只包含数字的Ex 命令，那么 Vim 会把这个数字解析成一个地址，并把光标移动到该数字所指定的行上。比如:3 跳到第3行。</span></li>
</ul>
<p><span style="line-height: 1.5;">　　</span></p>
<h2 class="not">用高亮选区指定范围</h2>
<p>　　当高亮选中后，按下:时，就会触发选定范围。此时在Ex 命令会显示":'&lt;,'&gt;"。</p>
<p>　　'&lt;，表示高亮选中的开头，'&gt;表示高亮选中的结尾。</p>
<h2 class="not">用模式指定范围</h2>
<p>　　Vim 也接受以模式作为一条 Ex 命令的地址。 :/{pattern1}/,/{pattern2}/。</p>
<p>　　例如：</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201508/051032093455518.png" alt="" width="466" height="151" /></p>
<p>　　这个范围看起来比较复杂，但实际上它符合范围的一般形式:{start},{end}。在本例中，{start} 地址是模式/&lt;html&gt;/，而{end} 地址是/&lt;\/html&gt;/。换句话说，这个范围由&lt;html&gt; 开标签所在的行开始，到对应闭标签所在的行结。　　</p>
<p>　　在此例中，用地址:2,5 也可以获得同样的结果，并且这种表示方式更简洁，不过它也更不可靠。用模式指定范围的话，我们的命令总是对整个&lt;html&gt;&lt;/html&gt; 范围进行操作，无论这个范围包含多少行都没问题。</p>
<p>　　</p>
<h2 class="not">用偏移对地址进行修正范围</h2>
<p><span style="line-height: 1.5;">　　接着上面的例子，假设我们想对位于&lt;html&gt;&lt;/html&gt;之间的每一行都运行一条 Ex 命令，但是不想</span>包括&lt;html&gt; 及&lt;/html&gt; 标签所在的行，那么此时偏移量就有大用了。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201508/051037204557471.png" alt="" width="461" height="116" /></p>
<p>　　偏移的一般形式是这样的：":{addr}+n"。</p>
<p>　　<span style="line-height: 1.5;">{addr} 可以是一个{address}&nbsp;</span>或是一个查找模式。可以+n，也可以减-1。"+"表示向下偏移，"-"表示向上偏移</p>
<h1>动作</h1>
<h2 class="not">复制</h2>
<p>　　语法：:[range]t{address}　　t==(t|copy|co)</p>
<p>　　例如：</p>
<p><img src="http://images0.cnblogs.com/blog2015/762312/201508/051101128307106.png" alt="" width="593" height="225" /></p>
<p>　　注意事项：</p>
<ul>
<li>
<p>在上表中，也可以将yyp 变化一下来复制我们想要的行，但不管怎样，这都需要一些额外的移动动作。我们得先跳到想复制的行上（6G），复制该行（yy），快速跳回原先的位置（&lt;C-o&gt;），然后再用粘贴命令（p）创建一个副本。由此可见，在复制距离较远的行时，:t 命令通常更加高效。</p>
</li>
</ul>
<h2 class="not">移动</h2>
<p>　　语法：:[range]m[ove]{address}</p>
<p>　　使用方法同复制非常像，就不单作解释了。</p>
<h2 class="not">显示</h2>
<p>　　想把匹配到东西显示出来的时候可以使用这个动作。</p>
<p>　　语法：:[range]p[rint] &nbsp; &nbsp;&nbsp;</p>
<h2 class="not">连接</h2>
<p>　　把文本连接成一行的时候可以使用这个动作。</p>
<p>　　语法：:[range]j[oin]</p>
<h2 class="not">删除</h2>
<p>　　语法：:[range]d[elete][x]　　　　　　</p>
<p>　　可以把删除的内容放到寄存器x里。</p>
<h2 class="not">读</h2>
<p>　　读取文本到当前缓存</p>
<p>　　语法1：[range]r[ead] &nbsp;!{cmd}　　这里的{cmd}指的是外部的命令</p>
<p>　　语法2：[range]r[ead] &nbsp;{filename} &nbsp;这里的{filename}指的是文件名称</p>
<p>　　注意事项：</p>
<ul>
<li>这里的[range]如果是一个范围的话，只会取最后的位置</li>
</ul>
<h2 class="not">写</h2>
<p>　　把当前的缓存写到其他地方</p>
<p>&nbsp; 这里的{filename}指的是文件名称</p>
<p>　　语法如下</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 300px;">命令</th><th>用途</th></tr>
<tr>
<td>:[range]w[rite] &nbsp;{filename}</td>
<td>把范围的文本写到指定的文件里。如果文件存在，不能直接覆盖</td>
</tr>
<tr>
<td>:[range]w[rite]! &nbsp;{filename}</td>
<td>把范围的文本写到指定的文件里。如果文件存在，直接覆盖</td>
</tr>
<tr>
<td>:[range]w[rite] &nbsp;&gt;&gt;</td>
<td>把范围的文本追加到当前文件尾。不过在窗口不会刷新出来。</td>
</tr>
<tr>
<td>:[range]w[rite] &nbsp;&gt;&gt; {filename}</td>
<td>把范围的文本追加指定的文件尾。</td>
</tr>
<tr>
<td>:[range]w[rite] &nbsp;!{cmd}</td>
<td>把范围文本当作标准输入文本调用命令</td>
</tr>
</tbody>
</table>
<p>　　注意事项：</p>
<ul>
<li>如果没有[range]和{filename}，相当于覆盖当前文件</li>
</ul>
<h2 class="not">normal</h2>
<p>　　在一系列连续行上执行一条普通模式命令。此命令在与. 命令或宏结合使用时，我们只需花费很少的努力就能完成大量重复性任务。</p>
<p>　　语法：:[range]normal {commands} &nbsp;&nbsp;</p>
<p>　　注意事项</p>
<ul>
<li>{commands}是普通模式的命令</li>
</ul>
<p>　　例如</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#想给所有行添加注释

#使用normal
:</span>%<span style="color: #000000;"> normal I#

#使用替换
:</span>%s /^/#/g</pre>
</div>
<h2>global</h2>
<p>　　结合了Ex 命令与Vim 的模式匹配这两方面能力。凭借该命令，我们可以在某个指定模式的所有匹配行上运行Ex 命令。就处理重复工作的效率而言，global 命令是除点范式以及宏之外，最为强大的Vim 工具之一。</p>
<p>　　语法：:[range] global[!] /{pattern}/ [cmd]</p>
<p>　　注意事项</p>
<ul>
<li>
<p>在缺省情况下，:global 命令的作用范围是整个文件（%），这一点与其他大多数Ex 命令（包括 :delete、:substitute 以及:normal）有所不同，这些命令的缺省范围仅为当前行（.）。</p>
</li>
<li>反选使用:vglobal 或简写的:v。想对不匹配的内容操作的时候，可以使用这个命令。比如不匹配的全部删除：:v/{pattern}/d</li>
<li>:print 是:global 命令的缺省[cmd]</li>
</ul>
<h2>查找</h2>
<p>　　语法：(/|?){pattern}</p>
<h3>方向</h3>
<ul>
<li>以/开头的，向后查找</li>
<li>以?开头的，向前查找</li>
</ul>
<h3>重复查找</h3>
<ul>
<li>n &nbsp; &nbsp; 继续相当的方向查找</li>
<li>N &nbsp; &nbsp; 取相反的方向查找</li>
</ul>
<h3>关闭高亮功能的快捷键</h3>
<p><span style="line-height: 1.5;">　</span>　:noh &lt;CR&gt; 虽然可以禁用查找高亮功能，但我们在键盘操作上也花费了不少功夫。通过创建映射项，可以让我们加速操作。</p>
<p>　　例如：</p>
<p>　　nnoremap &lt;silent&gt; &lt;C-l&gt; :&lt;C-u&gt;nohlsearch&lt;CR&gt;&lt;C-l&gt;</p>
<p>　　&lt;C-l&gt; 通常用于清除并重绘显示屏（参:h CTRL-L ）。而新的映射项，是在原有基础之上增加了暂时关闭查找高亮的功能。</p>
<p>　　这个用起来很带感哈。</p>
<h3>在执行查找前预览第一处匹配　　</h3>
<p>　　每次查找的时候定位到第一处匹配的位置。按esc的时候回到原来的位置。</p>
<p>　　开启语法：:incsearch</p>
<p>　　可以用于检查是否存在一处匹配。</p>
<p>　　例如</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">　　假设我们只想确认单词&ldquo;carrot&rdquo;是否在当前文档中出现，却不想移动光标，该怎么办呢？
　　当&lsquo;incsearch&rsquo;选项被启用时，我们只需简单地调出查找提示符，并尽可能多地输入组成单词&ldquo;carrot&rdquo;的字符，直到该单词首次映入我们的眼帘。
　　一旦找到该单词，我们只需按下</span>&lt;Esc&gt; ，即可马上结束查找并返回原位，从而避免打断我们的思维。</pre>
</div>
<p>&nbsp;</p>
<h3>根据预览结果对查找域自动补全</h3>
<p>　　此法会用当前预览的匹配结果对查找域进行自动补全。单词长的时候特别好用！！力荐</p>
<p>　　语法：&lt;C-r&gt;&lt;C-w&gt;&nbsp;</p>
<p>　　例如</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#文本里有一个单词like。
<br />#查找步骤
</span>/<span style="color: #000000;">li
</span>&lt;C-r&gt;&lt;C-W&gt;<span style="color: #000000;">
#此时会显示</span>/like</pre>
</div>
<p>&nbsp;</p>
<h3>将光标偏移到查找匹配的结尾</h3>
<p>　　会把光标定位到查找匹配的字符的结尾位置。如果不加的话会放在开始位置。</p>
<p>　　语法：/{pattern}/e</p>
<p>　　注意事项</p>
<ul>
<li>这里的"/"可以换成"?"，不过两个"/"，都必须换。就像这样：?{pattern}?e</li>
</ul>
<h3>查找当前选中的文本</h3>
<p>　　可以通过寄存器来实现。</p>
<p>　　步骤如下：</p>
<ol>
<li>用visual模式选中要查找的文本</li>
<li>然后使用y复制到寄存器""里。</li>
<li>最后输入/&lt;C-r&gt;"&lt;CR&gt;</li>
</ol>
<h2>替换</h2>
<p>　　语法：:[range]s[ubstitute]/{pattern}/{string}/[flags]</p>
<h3 class="not">重用上次的查找模式</h3>
<p>　　执行substitute 命令通常包括两个步骤：一是撰写查找模式，二是设计合适的替换字符串。因此，一分为二的技术让我们消除了这两项任务的耦合性，这才是关键所在。</p>
<p>　　将substitute 命令的查找域留空，意味着Vim 将会重用上次的查找模式。我们可以利用这一特点精简工作过程。</p>
<p>　　例如</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"># 看看这个庞大的substitute 命令吧
:</span>%s/\v<span style="color: #800000;">'</span><span style="color: #800000;">(([^</span><span style="color: #800000;">'</span>]|<span style="color: #800000;">'</span><span style="color: #800000;">\w)+)</span><span style="color: #800000;">'</span>/&ldquo;\<span style="color: #800080;">1</span>&rdquo;/<span style="color: #000000;">g

#它等价于以下两条单独的命令：
</span>/\v<span style="color: #800000;">'</span><span style="color: #800000;">(([^</span><span style="color: #800000;">'</span>]|<span style="color: #800000;">'</span><span style="color: #800000;">\w)+)</span><span style="color: #800000;">'</span><span style="color: #000000;">
:</span>%s<span style="color: #008000;">//</span><span style="color: #008000;">&ldquo;\1&rdquo;/g</span>
<span style="color: #000000;">
# 在我们撰写复杂的正则表达式过程中，通常需要尝试多次才能达到正确的匹配效果。
# 如果打算通过执行substitute 命令的方式来验证模式的话，每次执行命令都会改变文档的内容，这样做简直太麻烦了。
# 与之形成鲜明对比的是，当执行查找命令时，文档不会被修改。因此，即使我们犯的错误再多也无所谓


# 请注意，这个一般用于复杂的匹配。。如果很简单的匹配，就不要这么弄了。这个简单因人对正则的熟练度。
# 比如，</span><span style="color: #800080;">5</span><span style="color: #000000;">,10行加注释，这个简单一句话就可以解决了。
:</span><span style="color: #800080;">5</span>,10s/^/#/g</pre>
</div>
<p>&nbsp;</p>
<h3 class="not">用寄存器的内容替换</h3>
<p>　　输入入&lt;C-r&gt;{register}，我们可以将寄存器的内容插入到命令行&nbsp;</p>
<h3 class="not">标记</h3>
<p>　　{flags}。不同的标记影响替换的行为。</p>
<p>　　具体功能如下</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">字符</th><th>行为</th></tr>
<tr>
<td>&amp;</td>
<td>保持上一个替换的标记</td>
</tr>
<tr>
<td>c</td>
<td>需要进行确认</td>
</tr>
<tr>
<td>e</td>
<td>如果有错误，不提示错误信息。暂时没有找到比较不错的场景</td>
</tr>
<tr>
<td>g</td>
<td>作用于全部匹配的内容</td>
</tr>
<tr>
<td>i</td>
<td>忽略大小写字母敏感</td>
</tr>
<tr>
<td>I</td>
<td>大小写字母敏感</td>
</tr>
<tr>
<td>n</td>
<td>统计计数，不执行替换内容。</td>
</tr>
<tr>
<td>p</td>
<td>打印出最后一次匹配的内容。如果有设置显示行号，则显示，没有设置则不显示行号</td>
</tr>
<tr>
<td>#</td>
<td>打印出最后一次匹配的内容，并且显示行号。</td>
</tr>
<tr>
<td>l</td>
<td>打印出最后一次匹配的内容，但是打印的内容和:list一致。按我理解是多打印出逃逸字符</td>
</tr>
</tbody>
</table>
<p>&nbsp;　　技巧：</p>
<p>　　统计当前模式的匹配个数　　　</p>
<div class="cnblogs_code">
<pre>/<span>{pattern}                #这个就是我们要统计的模式
:%s///gn　　　　　　　　　　　#抑止执行</span></pre>
</div>
<h1>模式</h1>
<p>　　即{pattern}。</p>
<p>　　让我们先把目光集中在驱动它们运行的核心上，即Vim 的搜索引擎。你是否曾经想过Vim 的正则表达式是如何工作的？或者怎样关掉它们？</p>
<p>　　Vim 的正则表达式引擎可能与你惯用的其他引擎有所不同。我们将会看到，最易混淆的差异可被very magic 模式开关轻松化解。</p>
<h2 class="not">大小写敏感</h2>
<p>　　一般默认的是大小写敏感的。如果需要强制，在字符串后面加上标志即可。</p>
<ul>
<li>\c(小写c)，表示大小写不敏感</li>
<li>\C(大写c)，表示大小写敏感</li>
</ul>
<p>　　例如</p>
<div class="cnblogs_code">
<pre>#查找单词<span style="color: #800000;">"</span><span style="color: #800000;">word</span><span style="color: #800000;">"，</span><span style="color: #000000;">大小写不敏感
</span>/<span style="color: #000000;">word\c
#查找单词</span><span style="color: #800000;">"</span><span style="color: #800000;">word</span><span style="color: #800000;">"，</span><span style="color: #000000;">大小写敏感
</span>/<span style="color: #000000;">word\C

#把单词&ldquo;word</span><span style="color: #800000;">"</span><span style="color: #800000;">替换为</span><span style="color: #800000;">"</span>me<span style="color: #800000;">"</span><span style="color: #800000;">，大小写不敏感</span>
:%s/word\c/me/<span style="color: #000000;">g
#把单词&ldquo;word</span><span style="color: #800000;">"</span><span style="color: #800000;">替换为</span><span style="color: #800000;">"</span>me<span style="color: #800000;">"</span><span style="color: #800000;">，大小写敏感</span>
:%s/word\C/me/g</pre>
</div>
<p>&nbsp;</p>
<h2>vim的正则</h2>
<p>　　与Perl 相比，Vim 正则表达式的语法风格更接近POSIX。</p>
<p>　　但是，通过使用very magic 模式开关，就可以让Vim 采用我们更为熟悉的正则表达式语法了。</p>
<p><span style="line-height: 1.5;">　　缺省使用的是magic模式。通过\v(小写v)可以使用very magic模式。通过\V(大写v)可以very nomagic模式。</span></p>
<p>例如</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#假设我们要构造一个正则表达式，用于匹配以下CSS 片段中的每一组颜色代码：
body { color: #3c3c3c; }
a { color: #0000EE; }
strong { color: #</span><span style="color: #800080;">000</span><span style="color: #000000;">; }

#用magic 搜索模式查找十六进制颜色代码
</span>/#\([<span style="color: #800080;">0</span>-9a-fA-F]\{<span style="color: #800080;">6</span>}\|[<span style="color: #800080;">0</span>-9a-fA-F]\{<span style="color: #800080;">3</span><span style="color: #000000;">}\)

#用very magic 搜索模式查找十六进制颜色代码
</span>/\v#([<span style="color: #800080;">0</span>-9a-fA-F]{<span style="color: #800080;">6</span>}|[<span style="color: #800080;">0</span>-9a-fA-F]{<span style="color: #800080;">3</span><span style="color: #000000;">})

#用十六进制字符类进一步优化模式
</span>/\v#(\x{<span style="color: #800080;">6</span>}|\x{<span style="color: #800080;">3</span>})</pre>
</div>
<p>&nbsp;</p>
<p>　　注意事项</p>
<ul>
<li>在此例中，magic模式我们用到了3 类括号。方括号缺省具有特殊含义，因此不用转义。圆括号会按原义匹配字符(及)，因此需要转义，使其具有特殊含义。花括号也一样需要转义，不过，我们只需为开括号转义，而与之对应的闭括号则不用，因为Vim 会推测我们的意图。圆括号的情况有所不同，无论开闭括号都必须转义。</li>
</ul>
<h3>magic模式</h3>
<p>　　模式会自动为某些额外的符号赋予特殊含义，例如：. 、* 以及方括号。magic模式的设计初衷，是想能更容易地构造简单的正则表达式，但它却没能为诸如 +、？、圆括号以及花括号等符号赋予特殊含义，这些符号还必须经过转义才具有特殊含义。</p>
<h3>nomagic模式</h3>
<p>　　暂时还不是很清楚？？？</p>
<h3>very magic模式　　</h3>
<p>　　开关正好弥补了这一点，除了 _、数字以及字母外，它为所有符号都赋予了特殊含义。这样一来，既好记又恰好与Perl 正则表达式的规则保持一致。</p>
<h3>very nomagic模式</h3>
<p>　　在正则表达式中使用的特殊字符，在按模式查找时用起来很顺手，但如果我们想按原义查找文本时，它们就变成了阻碍。使用very nomagic 原义开关，可以消除附加在 .、* 以及? 等大多数字符上的特殊含义。</p>
<p>　　例如：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#文本内容
The N key searches backward...
...the \v pattern switch (a.k.a. very magic search)...

#现在假设我们想通过查找&ldquo;a.k.a.&rdquo;（此缩写表示also known as）的方式将光标移到
该处。针对这种情况，第一反应就是执行以下这条查找命令：
</span>/<span style="color: #000000;">a.k.a.

#实质上我们需要这么才能得到效果
</span>/a\.k\.a\.&lt;CR&gt;<span style="color: #000000;">

#或者，我们可以使用原义开关\V，激活very nomagic 搜索模式：
</span>/ \Va.k.a.</pre>
</div>
<p>&nbsp;</p>
<p class="not">　　注意事项</p>
<ul>
<li class="not">作为通用法则，如果你想按正则表达式查找，就用模式开关\v，而如果你想按原义查找文本，就用原义开关\V。这个要特别注意</li>
</ul>
<h3>特殊字符</h3>
<p>　　在几种模式的编写时，特殊字符比较容易混淆。</p>
<p>　　几种模式的特殊字符对应列表如下：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th>magic</th><th>nomagic</th><th>very magic</th><th>very nomagic</th><th>匹配内容</th></tr>
<tr>
<td>$</td>
<td>$</td>
<td>$</td>
<td>$</td>
<td>行尾</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>\.</td>
<td>\.</td>
<td>任何字符</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>\*</td>
<td>\*</td>
<td>任何个数</td>
</tr>
<tr>
<td>()</td>
<td>\(\)</td>
<td>\(\)</td>
<td>\(\)</td>
<td>组</td>
</tr>
<tr>
<td>|</td>
<td>\|</td>
<td>\|</td>
<td>\|</td>
<td>分隔符</td>
</tr>
<tr>
<td>\a</td>
<td>\a</td>
<td>\a</td>
<td>\a</td>
<td>字母表的字符</td>
</tr>
<tr>
<td>\\</td>
<td>\\</td>
<td>\\</td>
<td>\\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>\.</td>
<td>\.</td>
<td>.</td>
<td>.</td>
<td>字符点</td>
</tr>
<tr>
<td>\{</td>
<td>{</td>
<td>{</td>
<td>{</td>
<td>字符{</td>
</tr>
<tr>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>字符a</td>
</tr>
</tbody>
</table>
<p>　　</p>
<h2 class="not">匹配和高亮　</h2>
<p>　　当我们谈论一个模式的时候，指的是在查找域输入的正则表达式（或者按原义匹配的文本）；而匹配，是指在文档中被高亮显示的文本（假设已经启用'hlsearch'选项）。匹配和高亮是两件事。</p>
<p>　　有这么个东东，但是暂时没觉得有什么用处，试了一下暂时没体会到运用场景。</p>
<p>　　语法：</p>
<ul>
<li>/zs &nbsp;高亮开始</li>
<li>/ze &nbsp;高亮结果</li>
</ul>
<h1>运行Shell 命令</h1>
<p>　　我们不用离开 Vim 就能方便地调用外部程序。更棒的是，我们还可以把缓冲区的内容作为标准输入发送给一个外部命令，或是把外部命令的标准输出导入到缓冲区里。</p>
<p>　　在 Vim 中操作时，我们能很方便地调用shell 命令。下表选取了最有用的一些调用外部命令的方式</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">命令</th><th>用途</th></tr>
<tr>
<td>:shell</td>
<td>启动一个shell (输入exit 返回Vim)</td>
</tr>
<tr>
<td>:!{cmd}</td>
<td>在shell 中执行{cmd}</td>
</tr>
<tr>
<td>:read !{cmd}</td>
<td>在shell 中执行{cmd} ，并把其标准输出插入到光标下方</td>
</tr>
<tr>
<td>:[range]write !{cmd}</td>
<td>在shell 中执行{cmd} ，以[range] 作为其标准输入。这个暂时还没试明白？</td>
</tr>
<tr>
<td>:[range]!{filter}</td>
<td>使用外部程序{filter} 过滤指定的[range]</td>
</tr>
</tbody>
</table>
<p>　　运行shell命令一共有如下几种类型</p>
<h2 class="not">一次性外部</h2>
<p>　　适用于执行一次性命令。</p>
<p>　　语法：:!{cmd}&nbsp;</p>
<h2 class="not">交互</h2>
<p>　　适用于想在 shell 中执行几条命令。</p>
<p>　　语法：:shell</p>
<p>　　注意事项</p>
<ul>
<li>想要退出的时候，输入exit，即可返回vim</li>
</ul>
<h2 class="not">使用外部命令过滤缓冲区内容</h2>
<p>　　语法：:[range]!{filter}</p>
<p>　　例如</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#把当前文本排序一下

:</span>% !<span style="color: #0000ff;">sort</span></pre>
</div>
<p>&nbsp;</p>
<h2 class="not">把命令的标准输出重定向到缓冲区　　</h2>
<p>　　语法：:[range]read !{cmd}</p>
<p>　　例如</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#文件开头插入当前时间

:0r </span>!<span style="color: #0000ff;">date</span></pre>
</div>
<p>&nbsp;</p>
<p>　　注意事项</p>
<ul>
<li>如果没有[range]，则插入到当前光标位置</li>
<li>如果有[range]，以range后面的匹配的范围行为准</li>
</ul>]]></description></item><item><title>不断积累，愈发完美——《把时间当作朋友》读后感</title><link>http://www.cnblogs.com/ansn001/archive/2015/08/03/4698929.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 03 Aug 2015 05:52:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/08/03/4698929.html</guid><description><![CDATA[<p>　　把世界性的知识转化为属于自己的知识或者能力，才是我学习的真实目的。</p>
<p>　　读完第四遍，终于有一些自己的感触&mdash;&mdash;不断积累，愈发完美。</p>
<p>　　当然所有的感触，如若不落到实处，不管讲得再怎么对、再怎么激励人心，其实没有任何用处。感触极为多，也列了很多。但是太多的东西是没办法被执行的。</p>
<p>　　所以感触最终转变为：15条对我目前来说最需要积累的建议。虽然也觉得15条有点多，但是也许是贪心吧，不防先尝试一下。因为这里有很多不同维度，是可以在生活中主动并行的。等执行半年后再来一次验证和回顾，再进行下一轮的调整。</p>
<h3 class="top">每当想说&ldquo;我要。。。。&rdquo;的时候，就先思考一下&ldquo;我有。。。&rdquo;，看一下是否等价。</h3>
<p>　　所有东西都是等价的对换，不以人的情感转移，不要浪费时间在纠结上。如果不等价，那就花时间上积累&ldquo;我有。。。&rdquo;上。直到哪一天&ldquo;我有的&rdquo;和&ldquo;我想要的&rdquo;对等了，那就必然可以获得&ldquo;我想要的&rdquo;。</p>
<h3 class="top">要低调，不要喜欢秀优越感。</h3>
<p>　　不要浪费时间在没有意义、无聊的、浪费时间的秀优越感上。对比的喜悦是没有尽头的。而要落在真实的提升自己上面。</p>
<h3 class="top">不要把自己的经验当作道理，更不要当作真理。</h3>
<p>　　不要自以为是，浪费时间。更不要去祸害别人。</p>
<h3 class="top">一切要向着对自己好的方向看，一切事情都是好事。</h3>
<p>　　这样自己才能永远不断的在积累正向的能力上。后悔是最没有用的。</p>
<h3 class="top">哪一个更合理，更现实就接受哪一个，而非哪一个更积极就接受哪一个。</h3>
<p>　　客观真实，不要不经过大脑凭感觉。</p>
<h3 class="top">只有在长时间的专注一件事的时候，才会发生奇迹的事。</h3>
<p>　　只要在专注一件事，就一定会慢慢往前走。就像滚雪球一样。专心、专注的做好当前这件事。</p>
<h3 class="top">千万不要焦虑。一旦焦虑了需要静下来思考一下怎么做。</h3>
<p>　　焦虑让人看不到真正的问题。单纯的焦虑于事无补。</p>
<h3 class="top">如果不是急于马上解决问题，那必需弄清概念。</h3>
<p>　　底子太薄，路子比较野。如果是需要马上解决的问题，就以最快的方式解决。如果不是的话，要弄清概念，不要欺骗自己。概念是决定自己能走多远和多高的根本。</p>
<h3 class="top">做事一定要目的明确，没有任何二义性，不要隐藏任何其他的心里的目的。</h3>
<p>　　每个人都有2个目的。一个是表达出来给别人的目的，一个是在自己内心的目的。往往在自己内心的目的比表达出来给别人的目的会多好几倍。这样真正在做事的时候工作量会是n倍。所以要努力使自己内心的目的和表达出来的目的是一致的。这样才能确保工作量是对待的。只好的办法，每个事只有一个目的。让这个目的在每个人的理解是一致的。</p>
<h3 class="top">要会合理的去做任务（截止时间，紧急程度，验收，熟悉度），永远只有一个最重要的任务。</h3>
<p>　　只有失败的任务，没有任务失败。</p>
<h3 class="top">千万不要和怕麻烦的人在一起，也不要跟怕麻烦的人交朋友。</h3>
<p>　　自己目前是&ldquo;泥菩萨过江&rdquo;。所以没有那么多精力在上面，也解决不了这么高尚的问题。</p>
<h3 class="top">要以自己的规则去判断别人灌输的观念和想法。</h3>
<p>　　这样才能不断的锻炼自己的思考能力。这样才能不断的校正自己的规则。</p>
<h3 class="top">沟通的时候说事实，不要说看法。</h3>
<p>　　看法与事无补。每个人的认知都是不一样的。就像拯救世界一样。有的人认为破坏才能拯救，有的人认为维护才是拯救。所以既然是要沟通，那就要说事实就好了。</p>
<h3 class="top">不要光在脑子里猜，说出来验证一下听到的信息是否正确。</h3>
<p>　　沟通是两个人的事，都涉及到加密和解密。每个人都以为对方会懂，其实对方并不一定或者往往是不懂的。不妨说出来验证一下。你的意思是.....，我理解的对吗？这样才能不断的纠正中去沟通到对方真实想法。</p>
<h3 class="top">多尝试努力的和家人交流，哪怕没什么话，关心关心他们的想法也是好的。</h3>
<p>　　这个是头等大事。不敢说一切奋斗是为了家人，至少一半吧。如果不交流，也许就会出现电视剧里的情景了：孤家寡人或者是后悔莫及。</p>
<hr />
<p>总结，就像《把时间当作朋友》里讲的一样：时间对于现实的人是朋友，对于不现实的人是敌人。我们应该运用心智，不断积累，最后才能获得解放 。不要浪费时间在去纠结和后悔客观的事情上。不要浪费时间在对现在的不满，因为这是过去积累的结果。如果不希望未来重现，那么应该从现在开始不断积累，提升自己。直到有更强的自己做自己更想做的事。</p>
<p>&nbsp;</p>]]></description></item><item><title>菜鸟vimer成长记——第2.3章、insert模式</title><link>http://www.cnblogs.com/ansn001/archive/2015/07/30/4685307.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Thu, 30 Jul 2015 02:10:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/07/30/4685307.html</guid><description><![CDATA[<p>大部分的Vim 命令都在非插入模式中执行，不过有些功能在插入模式中会更好实现些。</p>
<p>如果没有输入当前文件不存在的新文本的需求时，建议通过其他模式来操作完成。</p>
<h1>目的</h1>
<p>　　掌握inser模式下常用操作的语法和概念</p>
<h1>光标移动</h1>
<p>　　移动光标的位置，这些操作和其他的编辑器基本一致。列几个常用的，其他的不一一列举。</p>
<p>　　常用语法：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作</th><th>用途</th></tr>
<tr>
<td>Ctrl+Left</td>
<td>向后移动一个单词</td>
</tr>
<tr>
<td>Ctrl+Right</td>
<td>向前移动一个单词</td>
</tr>
<tr>
<td>Home</td>
<td>移动到行首</td>
</tr>
<tr>
<td>End</td>
<td>移动到行尾</td>
</tr>
<tr>
<td>Ctrl+Home</td>
<td>移动到文件第一行</td>
</tr>
<tr>
<td>Ctrl+End</td>
<td>移动到文件最后一行</td>
</tr>
<tr>
<td>PageUp</td>
<td>向上一屏</td>
</tr>
<tr>
<td>PageDown</td>
<td>向下一屏</td>
</tr>
</tbody>
</table>
<p>　　详情查看:h&nbsp;ins-special-special</p>
<h1>更正错误</h1>
<p>　　在输入的时候，难免会输错。怎么更快速的更正这些错误呢？</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">情景一：在输入时打错
    我们可以用退格键删除错误的文本，然后再输入正确的内容。如果出错的地方靠近单词结尾，这或许是最快的修正方式。

情景二：出错的位置在单词开头
    专业打字员会建议先删除整个单词，然后再重新输入一遍。如果你能以每分钟超过60 个单词的速度输入，那么重新输入一个词只需要1 秒钟的时间。即便你打不了这么快，最好也采用这种方式。我以前总是输错某些特定的词，但自从采纳这一建议后，我就更清楚地意识到哪些词会让我犯错，因此现在犯的错也少了很多。
    另外，你也可以切换到普通模式，然后跳到这个词的开头并更正错误，再按 A 返回刚才的位置。不过完成这一套动作要花的时间可能不止1 秒钟，并且它也无助于提高你的盲打技巧。虽然说我们可以切换模式，不过这并不意味着一定就得切换。</span></pre>
</div>
<p>　　所以删除错误并且重新输入是最佳方法。</p>
<p>　　删除时有如下对应的快捷键操作：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作</th><th>用途</th></tr>
<tr>
<td>Ctrl+h</td>
<td>删除前一个字符（同退格键）</td>
</tr>
<tr>
<td>Del</td>
<td>删除后一个字符。很少用</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>删除前一个单词</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>删除到行首</td>
</tr>
</tbody>
</table>
<p>&nbsp;　　注意事项：</p>
<ul>
<li>这几个删除在shell以及cmd-line一样可以使用。</li>
</ul>
<h1>插入现有文本</h1>
<p>　　如果是当前没有的文本，通过键盘录入即可插入到当前光标。如果是是当前现有的文本到，可以通过多种途径插入当前光标。</p>
<p>　　这些途径如下：</p>
<h2>上下行</h2>
<p>　　复制光标处在位置的上下行字符。每次操作一次复制一个字符。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/291133084703343.png" alt="" width="467" height="261" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作</th><th>用途</th></tr>
<tr>
<td>Ctrl+E</td>
<td>复制下一行光标位置的字符到当前光标</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>复制上一行光标位置的字符到当前光标</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2>上一次</h2>
<p>　　复制上一次进入insert模式插入的内容。</p>
<p>　　语法：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作</th><th>用途</th></tr>
<tr>
<td>Ctrl+A</td>
<td>复制上一次进入insert模式插入的内容。</td>
</tr>
<tr>
<td>Ctrl+o</td>
<td>复制上一次进入insert模式插入的内容，并且退到normal模式</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2>寄存器</h2>
<p>　　复制寄存器里的内容。</p>
<p>　　语法：CTRL-R {0-9a-z"%#*+:.-=}</p>
<p>　　注意事项：</p>
<ul>
<li>查看所有寄存器的方法:reg</li>
<li>在normal模式中使用put&nbsp;{0-9a-z"%#*+:.-=}，可以实现黏贴。</li>
</ul>
<p>　　在本文顺便介绍一下寄存器的类型。请注意：下面寄存器的名称开头都会多加一个"（双引号）。详细查看:h registers</p>
<h3>无名（unnamed）寄存器</h3>
<p>　　""，缓存最后一次操作内容；</p>
<h3>数字（numbered）寄存器</h3>
<p>　　"0&nbsp;～&nbsp;"9，缓存最近操作内容，复制与删除有别。</p>
<ul>
<li>"0寄存器缓存最近一次复制的内容。</li>
<li>"1-"9缓存最近9次行删除内容</li>
</ul>
<h3>行内删除（small delete）寄存器</h3>
<p>　　"-，缓存行内删除内容</p>
<h3>具名（named）寄存器</h3>
<p>　　"a ～ "z或"A -&nbsp;"0Z，指定时可用；</p>
<p>　　定义一个具名寄存器的语法：在normal模式下"{name}y{motion}。这个输入可以注意右下角，会有对应的输入提示。</p>
<h3>只读（read-only）寄存器</h3>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">寄存器</th><th>代表的内容</th></tr>
<tr>
<td>":</td>
<td>最近cmd-line模式执行的命令</td>
</tr>
<tr>
<td>".</td>
<td>上次进入插入模式插入的文本</td>
</tr>
<tr>
<td>"%</td>
<td>当前文件名</td>
</tr>
<tr>
<td>"#</td>
<td>上一个轮换文件名。</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3>表达式（expression）寄存器</h3>
<p>　　"=，只读，用于执行表达式命令；</p>
<p>　　例如：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#假设我们刚输入完下列内容，我们想算一下总价然后再输入
</span><span style="color: #800080;">6</span> chairs, each costing $<span style="color: #800080;">35</span>, totals $<br />#只要输入&lt;C-r&gt;=6*35&lt;CR&gt;就可以得到结果</pre>
</div>
<p>&nbsp;</p>
<h3>选择及拖拽（selection and drop）寄存器</h3>
<p>　　"*,&nbsp;"+,&nbsp;"~，存取GUI选择文本，可用于与外部应用交互，使用前提为系统剪切板（clipboard）可用；</p>
<p>　　其他的命令只在vim里才有效。</p>
<h3>黑洞（black hole）寄存器</h3>
<p>　　"_，不缓存操作内容（干净删除）；</p>
<p>　　删除文本却不想覆盖无名寄存器中的内容时，此命令很管用。</p>
<h3>模式寄存器（last search pattern）</h3>
<p>　　"/，缓存最近的搜索模式。</p>
<p>&nbsp;</p>
<h2>自动提示</h2>
<p>　　语法：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">命令</th><th>补全类型</th></tr>
<tr>
<td>&lt;C-n&gt;</td>
<td>普通关键字</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-n&gt;</td>
<td>当前缓冲区关键字</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-i&gt;</td>
<td>包含文件关键字</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-]&gt;</td>
<td>标签文件关键字。？？这个暂时放到后面，可能单开一个文章来说明。</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-k&gt;</td>
<td>字典查找</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-l&gt;</td>
<td>整行补全</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-f&gt;</td>
<td>文件名补全</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-o&gt;</td>
<td>全能（Omni）补全</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-s&gt;</td>
<td>拼写建议</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-v&gt;</td>
<td>vim命令</td>
</tr>
<tr>
<td>&lt;C-x&gt;&lt;C-d&gt;</td>
<td>补全宏。？？这个暂时没有找到对应的使用方式</td>
</tr>
</tbody>
</table>
<p>　　不论使用哪种自动补全命令，都会弹出式菜单。</p>
<p>　　可供弹出式菜单使用的命令：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">按键操作</th><th>作用</th></tr>
<tr>
<td>&lt;C-n&gt;</td>
<td>使用来自补全列表的下一个匹配项（next 匹配项</td>
</tr>
<tr>
<td>&lt;C-p&gt;</td>
<td>使用来自补全列表的上一个匹配项（previous 匹配项）</td>
</tr>
<tr>
<td>&lt;Down&gt;</td>
<td>选择来自补全列表的下一个匹配项</td>
</tr>
<tr>
<td>&lt;Up&gt;</td>
<td>选择来自补全列表的上一个匹配项</td>
</tr>
<tr>
<td>&lt;C-y&gt;</td>
<td>确认使用当前选中的匹配项（yes）</td>
</tr>
<tr>
<td>&lt;C-e&gt;</td>
<td>还原最早输入的文本（从自动补全中exit）</td>
</tr>
<tr>
<td>&lt;C-h&gt; （与&lt;BS&gt;）</td>
<td>从当前匹配项中删除一个字符</td>
</tr>
<tr>
<td>&lt;C-l&gt;</td>
<td>从当前匹配项中增加一个字符</td>
</tr>
<tr>
<td>{char}</td>
<td>中止自动补全并插入字符{char}</td>
</tr>
</tbody>
</table>
<p>　　还有一些使用技术如下</p>
<h3>使用字典中的单词进行自动补全</h3>
<p>　　这个其实就是&lt;C-X&gt;&lt;C-K&gt;</p>
<p>　　有时候，我们可能想通过自动补全功能输入某个单词，但它并没有在任何打开的缓冲区、包含文件或者标签文件中出现过。在这种情况下，可以在字典中进行查找。</p>
<p><span style="line-height: 1.5;">　　为了激活该功能，我们需要为Vim 提供一份合适的单词列表。最简单的方法</span><span style="line-height: 1.5;">就是通过运行:set spell 来激活Vim 的拼写检查功能。</span></p>
<p>　　如果你不想激活拼写检查功能，也可以通过 &lsquo;dictionary&rsquo; 选项来指定一个或多个含有单词列表的文件（参见:h 'dictionary' ）。</p>
<p>　　<span style="line-height: 1.5;">当你想输入一个长单词或者很难拼写的单词时，字典自动补全也许最管用了。这</span><span style="line-height: 1.5;">里有一个例子</span></p>
<p><span style="line-height: 1.5;">　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/291911575015070.png" alt="" /></span></p>
<h3>自动补全文件名</h3>
<p>　　这个其实就是&lt;C-X&gt;&lt;C-F&gt;</p>
<p><span style="line-height: 1.5;">　　Vim 总是维护着一个当前工作目录，这一做法与shell 类似。在任何给定的时间点，</span><span style="line-height: 1.5;">我们都可以通过:pwd 命令（print working directory）获取到该信息，还可以通过:cd</span><span style="line-height: 1.5;">{path} 命令（change directory）随时切换工作目录。另外，Vim 的文件名自动补全功</span><span style="line-height: 1.5;">能只相对于工作目录的路径进行扩展，而不是相对于当前编辑文件的路径，理解这一</span><span style="line-height: 1.5;">点很重要。</span></p>
<p><span style="line-height: 1.5;">　　如果补全的是非当前工作目录的文件，我们的操作有两种方式：</span></p>
<p><span style="line-height: 1.5;">　　1、写路径的根目录，然后不断的通过&lt;C-X&gt;&lt;C-F&gt;来选择补全文件名。其实我比较喜欢这种方式</span></p>
<p><span style="line-height: 1.5;">　　2、先通过:cd{path}切换目录，然后&lt;C-X&gt;&lt;C-F&gt;补全，然后通过:cd - 切回原来的目录。</span></p>
<h3>根据上下文自动补全</h3>
<p>　　这个其实就是&lt;C-X&gt;&lt;C-O&gt;</p>
<p>　　<span style="line-height: 1.5;">全能补全是,它将提供一份为光标所处的上下文</span>量身定做的补全建议列表.</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/291920457828376.png" alt="" width="406" height="242" /></p>
<p>　　实际上，该功能由专用的文件类型插件实现，因此，我们必须先加载以下配置行:</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">set nocompatible
filetype plugin on</span></pre>
</div>
<p>　　Vim 的发行版本身就支持十几种语言，包括HTML、CSS、JavaScript、PHP 以及SQL。你可以通过:h compl-omni-filetypes 找到完整的列表</p>
<h3>减少按键次数</h3>
<p>　　只要和其他的快捷操作没有冲突都可以把两个操作变为一个。</p>
<p>　　建议设置如下：</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/291924232204714.png" alt="" width="457" height="175" /></p>
<h1>缩进</h1>
<p>　　语法：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作</th><th>用途</th></tr>
<tr>
<td>Ctrl+T</td>
<td>插入一个缩进</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>删除一个缩进</td>
</tr>
<tr>
<td>0（数字零）+Ctrl+D</td>
<td>删除当前行的所有缩进</td>
</tr>
<tr>
<td>^+Ctrl+D</td>
<td>删除当前行的所有缩进。和上面的区别暂时还没试出来？？</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h1>缩写</h1>
<p>　　缩写可以用于insert和cmd-line模式。这些命令都差不多，只是通过前缀区别。单一个字符是i的表示适合于insert模式。如果是c的表示适合于cmd-line模式。如果没写的，表示两个都可以使用。</p>
<p>　　下面仅列出都适用的列表，其他的大家对号入座</p>
<p>　　其中{lhs}表示缩写的字符串。{rhs}表示真实的字符串，这里面支持map-&lt;expr&gt;,map-&lt;buffer&gt;</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作</th><th>用途</th></tr>
<tr>
<td>:ab {lhs}</td>
<td>查看缩写的列表。如果不写就是所有缩写列表;如果有写就是找到匹配的列表</td>
</tr>
<tr>
<td>:ab &nbsp;{lhs} {rhs}</td>
<td>定义一个缩写</td>
</tr>
<tr>
<td>:una {lhs}</td>
<td>删除缩写列表。如果不写就是删除所有列表;如果有写就是删除匹配的列表</td>
</tr>
</tbody>
</table>
<p>　　使用缩写例子</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#定义了一个:ab syso System.out.println();

#列举insert模式例子，cmd</span>-<span style="color: #000000;">line模式是一样的。${CURSOR}代表光标位置

#能生效的缩写。
</span><span style="color: #800000;">"</span><span style="color: #800000;">  syso{CURSOR}</span><span style="color: #800000;">"</span><span style="color: #000000;">     #注意,syso的前面有空白文本
#此时只要继续按一下非关键字符（tab键</span>|<span style="color: #000000;">空格键|Enter键|Esc键等）

#不能生效的缩写
</span><span style="color: #800000;">"</span><span style="color: #800000;"> sysob{CURSOR}</span><span style="color: #800000;">"</span>
<span style="color: #800000;">"</span><span style="color: #800000;">testsyso{CURSOR}</span><span style="color: #800000;">"</span></pre>
</div>
<p>&nbsp;</p>
<p>　　所以，使用缩写的方法是：缩写必须是一个完整的独立的{rhs}输入。在{rhs}输入之前，前面需要有空白文本。在{rhs}输入之后不能再有任何其他的关键字符输入。</p>
<p>　　还有一些其他的，可以细看:h&nbsp;Abbreviations :h&nbsp;map-&lt;expr&gt;,:h map-&lt;buffer&gt;</p>
<h3>小技巧</h3>
<p>　　如果是通过cmd-line设置的缩写，关闭vim后就消除了。为了可以一直使用，可以写一个常用的缩写列表文件，然后放在vimrc文件中</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#vimrc文件
source $VIMRUNTIME</span>/my/ab.vim</pre>
</div>
<p>&nbsp;</p>
<h1>insert normal 模式</h1>
<p>　　它能让我们执行一次普遍模式命令。在此模式中，我们可以执行一个普通模式命令，执行完后，马上就又返回到插入模式。</p>
<p>　　语法：</p>
<p>　　Ctrl+o</p>
<p>　　例如：　</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">场景：在当前行正好处于窗口顶部或底部时，有时我会滚动一下屏幕，以便看到更多的上下文。<br />
　　用zz 命令可以重绘屏幕，并把当前行显示在窗口正中，这样就能够阅读当前行之上及之下的半屏内容。我常常会键入</span>&lt;C-o&gt;zz，在插入-普通模式中触发这条命令。此操作完成后就会直接回到插入模式，因此我可以不受中断地继续打字。</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>菜鸟vimer成长记——第2.2章、visual模式</title><link>http://www.cnblogs.com/ansn001/archive/2015/07/27/4680966.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 27 Jul 2015 11:05:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/07/27/4680966.html</guid><description><![CDATA[<p>　　vi是没有可视模式的。然而大多数编辑软件都都是有可视模式。所以我猜测vim是几乎迫于无奈才有了visual模式。</p>
<p>　　个人建议，能不用就不用。这样能直接在头脑里处理好文本，锻炼文本处理能力，同时能转变过来思维习惯。</p>
<h1>目的</h1>
<ul>
<li>掌握visual的基本操作步骤</li>
<li>记住visual独有的用法</li>
</ul>
<h1>使用步骤</h1>
<p>　　visual的操作可以分为三个步骤。可以对比normal的二个步骤：操作符+动作命令。</p>
<ol>
<li>激活可视模式。一个是因为绝大时间都在normal模式下，需要切换。第二个是因为visual有三种情况。</li>
<li>移动文本末端。通过移动文本的末端来选择高亮文本。</li>
<li>输入操作符。最后通过操作符完成本次文本操作。</li>
</ol>
<h1>激活可视模式</h1>
<p>　　Vim 具有3 种不同的可视模式，分别用于操作字符文本、行文本或块文本。</p>
<p>　　对应的开启语法如下：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">命令</th><th>用途</th></tr>
<tr>
<td>v</td>
<td>&nbsp;激活面向字符的可视模式</td>
</tr>
<tr>
<td>V</td>
<td>&nbsp;激活面向行的可视模式</td>
</tr>
<tr>
<td>Ctrl+v</td>
<td>&nbsp;激活面向列块的可视模式</td>
</tr>
<tr>
<td>gv</td>
<td>&nbsp;重选上次(字符，行，块都可以)的高亮选区</td>
</tr>
<tr>
<td>gn</td>
<td>激活面向字符的可视模式并选中最近一次搜索匹配的文本。相当于搜索的时候n。如果连续使用gn命令，则选取到下一块匹配文本</td>
</tr>
<tr>
<td>gN</td>
<td>激活面向字符的可视模式并选中最近一次搜索匹配的文本。相当于搜索的时候N。如果连续使用gn命令，则选取到上一块匹配文本</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h1>移动文本</h1>
<h2>动作命令</h2>
<p>　　和normal模式的动作命令的用法一样。这里不在赘述。</p>
<h2>修改光标位置</h2>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作按键</th><th>用途</th></tr>
<tr>
<td>o</td>
<td>切换高亮选区的活动端。即切换高度的开头和结尾</td>
</tr>
<tr>
<td>O(shift+o)</td>
<td>和o一样。只有在visual是块模式的时候，它表示的是当前行被选中的开头和结尾</td>
</tr>
</tbody>
</table>
<h1>操作符</h1>
<p>　　操作符也和normal模式基本一样。除了下面列的&ldquo;特殊情况&rdquo;的地方需要注意，其他的用法都是一样的。</p>
<h2>特殊情况</h2>
<ol>
<li>在可视模式及操作符待决模式中，i 和a 键表示文本选择的开头。即和normal的文本选择的a和i一个意思。所以按i,a并不能进入insert模式。</li>
<li>在可视模式及操作符待决模式中，o 和O 键表示切换高亮选区的活动端。所以也不能进入insert模式。</li>
</ol>
<h2>陷阱</h2>
<p>　　只要可能，最好用操作符命令，而不是可视命令。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#假设我们想把下面列表中的链接文字转换为大写格式：
</span>&lt;a href=<span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span>&gt;one&lt;/a&gt;
&lt;a href=<span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span>&gt;two&lt;/a&gt;
&lt;a href=<span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span>&gt;three&lt;/a&gt;</pre>
</div>
<p>　　使用可视模式下的命令进行大写转换：</p>
<p>　　1、我们先转一个单词为大写。<img src="http://images0.cnblogs.com/blog2015/762312/201507/271847192667984.png" alt="" width="289" height="198" /></p>
<p>　　2、好，我们执行一下j. 命令，把光标移到下一行并重复上次的修改。此命令在第二行工作得很好，但如果我们再执行一次，最终就会得到这个看起来有点古怪的结果：</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/271848582976398.png" alt="" /></p>
<p>　　使用普通模式下的操作符命令进行大写转换：</p>
<p>　　　　　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/271849448132919.png" alt="" width="314" height="228" /></p>
<p>　　结论：如果我们想使点命令能够重复某些有用的工作，那么最好要远离可视模式。作为一般的原则，在做一系列可重复的修改时，最好首选操作符命令，而不是其对应的可视模式命令。甚至我个人的建议是：不要使用visual模式。</p>
<h1>独有功能</h1>
<h2>列模式</h2>
<p>　　这个是visual独有的功能。在操作一些配置文件，而且文本复杂度很低的时候（比如不需要经过大脑计算就可以到达的，每个人因熟练度不同而异，比如3-10行），可以使用。</p>
<p>　　例如：</p>
<ul>
<li>修改hosts文件里域名的指向，光标前后几行的域名从内网的192.168.1.16修改为127.0.0.1的时候。</li>
<li>在编写脚本的时候，光标前后几行代码需要一会注释掉一会取消注释测试时。</li>
</ul>
<p>　　</p>]]></description></item><item><title>菜鸟vimer成长记——第2.1章、normal模式</title><link>http://www.cnblogs.com/ansn001/archive/2015/07/22/4655073.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Wed, 22 Jul 2015 03:20:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/07/22/4655073.html</guid><description><![CDATA[<h1>目的</h1>
<p>掌握normal模式下常用操作的语法和概念，这些操作对应的应用场景以及实用技巧。</p>
<p>通过normal模式举一反三掌握cmd-line和visual的常用文本操作。</p>
<h1>简介</h1>
<p>　　文本操作的理想状态为：一个操作符+一个动作命令。</p>
<p>　　normal、visual、cmd-line都具有操作文本的基本功能。</p>
<ul>
<li><span style="line-height: 1.5;">normal　　　　操作符+动作命令。</span></li>
<li><span style="line-height: 1.5;">visual　　　　 &nbsp;动作命令+操作符。</span></li>
<li><span style="line-height: 1.5;">cmd-line　　 &nbsp; 匹配范围+操作符。</span></li>
</ul>
<p><span style="line-height: 1.5;">　　这三个在文本的基础操作时实现的功能是一样的。主要围绕着normal来讲，其他的举一反三即可。</span></p>
<p><span style="line-height: 1.5;">　　<span class="Apple-tab-span">学习新的动作命令及操作符，就像是在学习Vim 的词汇一样。如果掌握了这一简单的语法规</span></span>则，通过组合，在<span style="line-height: 1.5;"><span class="Apple-tab-span"><span class="Apple-tab-span">词汇量增长时，就能表达更多的想法。所以必须明确每个操作的真实对应的概念，因为这些概念在整个vim都是通用的。</span></span></span></p>
<h1>统一规则　</h1>
<ul>
<li><span style="line-height: 1.5;">命令一般都是成对出现的，所以可以合起来记，这样记忆场景量能少一半。例如：</span>
<ul>
<li><span style="line-height: 1.5;">单词移动，从左向右和从右向左都有对应的动作命令。从左到右:w|W,e|E。从右向左：b|b,ge|gE.....</span></li>
<li><span style="line-height: 1.5;">屏幕滚动, 向前和向后。Ctrl+F|Ctrl+B, Ctrl+U|Ctrl+D</span></li>
<li><span style="line-height: 1.5;">大小写。gu |gU</span></li>
</ul>
</li>
<li><span style="line-height: 1.5;">命令是象形。理解这个象形，有助于记忆。例如：</span></li>
<ul>
<li>符号本身即表示向前还是向后的概念。),},],&gt;</li>
<li>小写的时候代表 word，大写的代表WORD。 单词移动：w(word),W(WORD)</li>
<li>比如在方向前加g，表示物理行和屏幕行。 k(移动到下一个物理行),gk(移动到下一个屏幕行)</li>
<li>大写代表到行尾。C相当于c$,D相当于d$。</li>
<li>大小写表示方向的。f{char} 从左向右查找，F{char}从右向左查找。</li>
<li>一个操作符命令被连续调用两次时，它会作用于当前行。比如：dd：删除当前行，yy:复制当前行,&gt;&gt;:缩进当前行......</li>
</ul>
</ul>
<h1>基本概念　　</h1>
<h3>单词</h3>
<p>　　由非空白字符组成的连贯的集合，由空白字符分隔。字符不包括关键字(iskeyword)。</p>
<p>　　详情可以查看:h word ,:h iskeyword。</p>
<h3>大单词</h3>
<p>　　由非空白字符组成的连贯的集合，由空白字符分隔。字符包括关键字(iskeyword)。</p>
<p>　　例如：</p>
<p>　　This is mine/yours</p>
<p>　　其中的"mine"是word，而"mine/yours"是一个WORD，这里"mine","/","yours"是三个word。这里的"/"就是iskeyword。</p>
<p>　　详情可以查看:h WORD,:h iskeyword。</p>
<h3>句子</h3>
<p>　　一个句子，以".","!","?"结尾。需要注意的是,是英文状态中的符号，中文状态下是无效的,比如"。"。</p>
<p>　　详情可以查看:h sentence。</p>
<h3>行</h3>
<p>　　实际行与屏幕行的区别。</p>
<p>　　与许多文本编辑器不同，Vim 会区分实际行与屏幕行。当&lsquo;wrap&rsquo; 设置被启用时 （缺省启用），每个超出窗口宽度的文本行都会被回绕显示，以保证没有文本显示不出 来。这样一来，文件中的一行也许会被显示为屏幕上的若干行。要想知道实际行与屏幕行之间的不同，最简单的方法是启用&lsquo;number&rsquo; 设置。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/191007380636949.png" alt="" /></p>
<p>　　理解实际行与屏幕行间的差别很重要，因为 Vim 提供了不同的动作命令来操作 这两者。j 和k 命令会根据实际行向下及向上移动，而gj 和gk 则是按屏幕行向下 及向上移动。即只要有加g就表示的是屏幕行，没有加g就表示的是实际行。</p>
<h3>段落</h3>
<p>　　以空行区分开段落。</p>
<p>　　详情可以查看:h paragraph。</p>
<h3>方法</h3>
<p>　　类似于java的编程语言的一个方法。</p>
<p>　　详情可以查看:h various-motions里的]m。</p>
<h3>结构</h3>
<p>　　有两种情况：</p>
<p>　　1、以一个符号开始，又以这个符号结束的。比如(),[],{},&lt;&gt;,"",''。</p>
<p>　　2、以标签开始，又以这个标签结束的。比如 &lt;aaa&gt; &lt;/aaa&gt;</p>
<p>　　这个主要是文本选择的时候用的比较多。一般会区分a和i(inner)。a表示整个结构,i表示这个结构内部的文本。</p>
<p>　　详情可以查看:h object-select ,:h tag-blocks。</p>
<h1><span class="Apple-tab-span">操作符</span></h1>
<p>　　约定：如果后面需要跟动作命令的用{motion}表示。</p>
<p>　　详情可以查看 :h operator ,:h xx(操作符)。</p>
<h3>修改</h3>
<p>　　定义：删除指定的文本并且进入insert模式。</p>
<p>　　语法：</p>
<table class="myTable" style="height: 157px; width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作符</th><th>实现功能</th></tr>
<tr>
<td>c{motion}</td>
<td>删除指定动作命令选择代表的文本并且进入insert模式</td>
</tr>
<tr>
<td>cc</td>
<td>删除当前行并且进入insert模式</td>
</tr>
<tr>
<td>C</td>
<td>删除到光标到行尾的文本并且进入insert模式。相当于c$</td>
</tr>
<tr>
<td>s</td>
<td>删除光标下的字符并且进入insert模式。相当于cl</td>
</tr>
<tr>
<td>S</td>
<td>删除当前行。相当于cc。 &nbsp;能不按shift键我都不愿意用shift。所以一般直接用cc</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3>删除</h3>
<p>　　定义：删除指定的文本。</p>
<p>　　语法：</p>
<table class="myTable" style="height: 157px; width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作符</th><th>实现功能</th></tr>
<tr>
<td>&nbsp;x</td>
<td>&nbsp;删除光标下的字符</td>
</tr>
<tr>
<td>&nbsp;X</td>
<td>&nbsp;删除光标前一个字符</td>
</tr>
<tr>
<td>&nbsp;d{motion}</td>
<td>&nbsp;删除指定动作命令代表的文本</td>
</tr>
<tr>
<td>&nbsp;dd</td>
<td>&nbsp;删除当前行</td>
</tr>
<tr>
<td>&nbsp;D</td>
<td>&nbsp;删除光标到当前行行尾。相当于d$</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3>大小写切换</h3>
<p>　　定义：指定的文本大小写切换。</p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作符</th><th>实现功能</th></tr>
<tr>
<td>~</td>
<td>切换光标下的字符大小写</td>
</tr>
<tr>
<td>~~</td>
<td>切换当前行的大小写</td>
</tr>
<tr>
<td>g~{motion}</td>
<td>切换动作命令代表的文本的大小写　&nbsp;</td>
</tr>
<tr>
<td>gu{motion}</td>
<td>把动作命令代表的文本变为小写</td>
</tr>
<tr>
<td>gugu</td>
<td>当前行变为小写</td>
</tr>
<tr>
<td>gU{motiong}</td>
<td>把动作命令代表的文本变为大写</td>
</tr>
<tr>
<td>gUgU</td>
<td>当前行变为大写</td>
</tr>
</tbody>
</table>
<p><span style="line-height: 1.5;">&nbsp;</span></p>
<h3>复制,粘贴</h3>
<p>　　定义：复制文本到寄存器。</p>
<p>　　语法：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作符</th><th>实现功能</th></tr>
<tr>
<td>y{motion}</td>
<td>复制动作命令代表的文本到寄存器</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行到寄存器</td>
</tr>
<tr>
<td>Y</td>
<td>复制当前行到寄存器，相当于yy。能不按shift键我都不愿意用shift。所以一般直接用yy<span style="line-height: 1.5;">　&nbsp;</span></td>
</tr>
</tbody>
</table>
<p>　　定义：把复制的文本粘贴出来。</p>
<p>　　语法：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作符</th><th>实现功能</th></tr>
<tr>
<td>p</td>
<td>把复制的文本粘贴到光标之后。如果复制的是行，则放在当前行的下面，并且光标停留在复制文本的第一行位置</td>
</tr>
<tr>
<td>P(Shift+p)</td>
<td>把复制的文本粘贴到光标之前。如果复制的是行，则放在当前行的上面，并且光标停留在复制文本的下一行位置</td>
</tr>
<tr>
<td>gp</td>
<td>把复制的文本粘贴到光标之后。如果复制的是行，则放在当前行的下面，并且光标停留在复制文本的第一行位置</td>
</tr>
<tr>
<td>gP(Shift+p)</td>
<td>把复制的文本粘贴到光标之前。如果复制的是行，则放在当前行的上面，并且光标停留在复制文本的下一行位置</td>
</tr>
</tbody>
</table>
<p>&nbsp;　　注意事项 ：</p>
<ul>
<li>有加g的操作符，如果是行复制需要注意。有加g最后光标停留在复制的文本的下一行，没加g最后光标停留在复制的文本第一行。</li>
</ul>
<h3>缩进</h3>
<p>　　定义：针对文本进行缩进。缩进针对的是行，所以是文本动作选择对应的行的缩进。</p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">操作符</th><th>实现功能</th></tr>
<tr>
<td>&gt;{motion}</td>
<td>向右缩进动作命令文本代表的行</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>向左缩进当前行</td>
</tr>
<tr>
<td>&lt;{motion}</td>
<td>向左缩进动作命令文本代表的行</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>向左缩进当前行</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3>折叠</h3>
<p>　　把文本折叠起来。此时操作折叠相当于操作一行。</p>
<p>　　这个现在暂时不涉及，感觉暂时应用不会太多，如果有用到后续会补充。&nbsp;</p>
<h1><span class="Apple-tab-span"><span class="Apple-tab-span">动作命令</span></span></h1>
<p><span class="Apple-tab-span"><span class="Apple-tab-span">　　</span>用来</span>选定要操作的文本的范围。</p>
<p>　　基本所有的动作命令前都可以加上量词{count}表示重复，就不在一一做说明。</p>
<p>　　详情可以查看 :h motion,:h usr_03.txt,:h xx(动作命令)。</p>
<h2>从当前光标到下一个光标</h2>
<h3>上下左右</h3>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211615059907493.png" alt="" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>h</td>
<td>向左移动一个字符</td>
</tr>
<tr>
<td>l</td>
<td>向右移动一个字符</td>
</tr>
<tr>
<td>j</td>
<td>向下移动一个实际行</td>
</tr>
<tr>
<td>gj</td>
<td>向下移动一个屏幕行</td>
</tr>
<tr>
<td>k</td>
<td>向上移动一个实际行</td>
</tr>
<tr>
<td>gk</td>
<td>向上移动一个屏幕行</td>
</tr>
</tbody>
</table>
<p style="margin-left: 30px;">&nbsp;注意事项：</p>
<ul>
<li>g用于区别实际行和屏幕行</li>
</ul>
<h3>行定位</h3>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211603442244844.png" alt="" width="471" height="184" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>0</td>
<td>移动到实际行的行首</td>
</tr>
<tr>
<td>g0</td>
<td>移动到屏幕行的行首</td>
</tr>
<tr>
<td>^</td>
<td>移动到实际行的第一个非空白字符</td>
</tr>
<tr>
<td>g^</td>
<td>移动到屏幕行的第一个非空白字符</td>
</tr>
<tr>
<td>$</td>
<td>移动到实际行的行尾</td>
</tr>
<tr>
<td>g$</td>
<td>移动到屏幕行的行尾</td>
</tr>
<tr>
<td>gm</td>
<td>移动到屏幕行的中间</td>
</tr>
<tr>
<td>+</td>
<td>移动到下一行行首第一个非空白字符</td>
</tr>
<tr>
<td>-</td>
<td>移动到上一行行首一个非空白字符</td>
</tr>
</tbody>
</table>
<p style="margin-left: 30px;">注意事项：</p>
<ul>
<li>0与^的区别在于非空白字符。</li>
<li>g用于区别实际行和屏幕行</li>
</ul>
<h3>行查找</h3>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211617495532559.png" alt="" width="549" height="100" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>F{char}</td>
<td>从右向左查找字符。光标停留在找到的字符上面。</td>
</tr>
<tr>
<td>f{char}</td>
<td>从左向右查找字符。光标停留在找到的字符上面。</td>
</tr>
<tr>
<td>T{char}</td>
<td>从左向右查找字符。光标停留在找到的字符后一个字符。</td>
</tr>
<tr>
<td>t{char}</td>
<td>从左向右查找字符。光标停留在找到的字符前一个字符。</td>
</tr>
<tr>
<td>;</td>
<td>重复上一次的行查找（f,F,t,T）</td>
</tr>
<tr>
<td>,</td>
<td>回到上一次的行查找的位置</td>
</tr>
</tbody>
</table>
<p style="margin-left: 30px;">注意事项：</p>
<ul>
<li>大写字母是从右向左，小写字母是从右向右</li>
<li>f系统是光标停留在查找到的字符上面，t系列是光标停留在查找到的字符临近一个字符。</li>
</ul>
<h3>行跨越&nbsp;</h3>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211620302877152.png" alt="" width="451" height="262" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>G</td>
<td>文件的最后一行</td>
</tr>
<tr>
<td>nG</td>
<td>跳到文件的第n行。</td>
</tr>
<tr>
<td>gg</td>
<td>文件第一行，相当于1G</td>
</tr>
<tr>
<td>n%</td>
<td>跳到文件的百分之n行。</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3>单词移动</h3>
<p style="margin-left: 30px;">&nbsp;<img src="http://images0.cnblogs.com/blog2015/762312/201507/191036427821295.png" alt="" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>w</td>
<td>从左向右，移动到下一个单词词首</td>
</tr>
<tr>
<td>W</td>
<td>从左向右，移动到下一个大单词词首。</td>
</tr>
<tr>
<td>b</td>
<td>从右向左，如果光标不是在词首。则移动到本单词词首。如果在词首移动到下一个单词词首。</td>
</tr>
<tr>
<td>B</td>
<td>从右向左，如果光标不是在词首。则移动到本单词词首。如果在词首移动到下一个大单词词首。</td>
</tr>
<tr>
<td>e</td>
<td>从左向右，如果光标不是在词尾，则移动到本单词词尾。如果在词尾移动到下一个单词词尾</td>
</tr>
<tr>
<td>E</td>
<td>从左向右，如果光标不是在词尾，则移动到本单词词尾。如果在词尾移动到下一个大单词词尾</td>
</tr>
<tr>
<td>ge</td>
<td>从右向左，移动到下一个单词词尾</td>
</tr>
<tr>
<td>gE</td>
<td>从右向左，移动到下一个大单词词尾</td>
</tr>
</tbody>
</table>
<p style="margin-left: 30px;">注意事项</p>
<ul>
<li>&nbsp;大写代表WORD,小写代表word</li>
</ul>
<h3>文本移动</h3>
<p>　　语法：</p>
<table class="myTable" style="width: 99%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>)</td>
<td>移动下一个句子句首。</td>
</tr>
<tr>
<td>(</td>
<td>移动上一个句子句首。</td>
</tr>
<tr>
<td>}</td>
<td>移动下一个段落段首前的空行上</td>
</tr>
<tr>
<td>{</td>
<td>移动上一个段落段首前的空行上</td>
</tr>
<tr>
<td>]]</td>
<td>移动到下一个以&ldquo;{"为第一个字符的行首。如果结合操作符，则停留下一个"{"的上一行。</td>
</tr>
<tr>
<td>[[</td>
<td>移动到上一个以&ldquo;{"为第一个字符的行首。如果结合操作符，则停留上一个"{"的那一行</td>
</tr>
<tr>
<td>][</td>
<td>移动到下一个以&ldquo;}"为第一个字符行首。如果结合操作符，则停留下一个"}"上一行</td>
</tr>
<tr>
<td>[]</td>
<td>移动到上一个以&ldquo;}"为第一个字符行首。如果结合操作符，则停留上一个"}"那一行</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3>标记</h3>
<p>　　标记有两类型的符号'(单引号),`(反撇键)。'，表示定位到行首。`，表示定位到行首的第一个非空白地方。后面跟的任何命令，两个类型都有，所以就不一一说明了只取'来做语法说明。</p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>m{a-zA-Z}</td>
<td>设置标记</td>
</tr>
<tr>
<td>'[</td>
<td>跳到最近一次修改或者复制文本的第一行位置</td>
</tr>
<tr>
<td>']&nbsp;</td>
<td>跳到最近一次修改或者复制文本的最后一行位置</td>
</tr>
<tr>
<td>'&gt;&nbsp;</td>
<td>跳到最近一次visual选择的最后一行位置</td>
</tr>
<tr>
<td>'&lt;</td>
<td>跳到最近一次visual选择的第一行位置</td>
</tr>
<tr>
<td>''(两个单引号)</td>
<td>跳到最近一次上方位置</td>
</tr>
<tr>
<td>'"</td>
<td>跳到文件上一次打开的最后位置</td>
</tr>
<tr>
<td>'^</td>
<td>跳到光标退出插入模式的地方</td>
</tr>
<tr>
<td>'.</td>
<td>跳到最后一次文件修改的地方 &nbsp;&nbsp;</td>
</tr>
<tr>
<td>]'</td>
<td>跳到上一个小写字母标记（用:marks查看）的地方</td>
</tr>
<tr>
<td>['</td>
<td>跳到下一个小写字母标记的地方</td>
</tr>
</tbody>
</table>
<p>&nbsp;　　注意事项：</p>
<ul>
<li>还有一些没有实际意义的，不列出来了。'),'},'(,'{ &nbsp;相当于(,),{,}。</li>
<li>需要注意的是：配合cmd-line下的:marks。查看所有标记 。</li>
</ul>
<p>　　详情可以查看:h marks。</p>
<h3>跳越</h3>
<p>　　一个跳越，指定的是使用以下命令: "'", "`", "G", "/", "?", "n","N", "%", "(", ")", "[[", "]]", "{", "}", ":s", ":tag", "L", "M", "H" 等命令</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211636536152107.png" alt="" width="496" height="198" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>Ctrl+o</td>
<td>跳到上一个光标位置</td>
</tr>
<tr>
<td>Ctrl+i</td>
<td>跳到下一个光标位置</td>
</tr>
<tr>
<td>ng,</td>
<td>向之前n次修改跳越</td>
</tr>
<tr>
<td>ng;</td>
<td>向之后n次修改跨越</td>
</tr>
</tbody>
</table>
<p><span style="line-height: 1.5;">　　注意事项：</span></p>
<ul>
<li><span style="line-height: 1.5;">配合cmd-line下的:jumps,查看所有跳越。</span></li>
<li><span style="line-height: 1.5;">配合cmd-line下的:changes，查看所有修改的跳越。</span></li>
</ul>
<p>　　详情可以查看:h jumps ,:h changes 。</p>
<h3>变量</h3>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211619553819150.png" alt="" width="369" height="173" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>%</td>
<td>找到匹配的([{}])</td>
</tr>
<tr>
<td>[(</td>
<td>找到不匹配的(</td>
</tr>
<tr>
<td>[{</td>
<td>找到上一个不匹配的{</td>
</tr>
<tr>
<td>]m</td>
<td>跳到下一个方法 &nbsp;</td>
</tr>
<tr>
<td>]符号(&nbsp;#，*，/)</td>
<td>跳到下一个符号的位置</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2>从当前光标选择区域文本</h2>
<h3>文本选择</h3>
<p>　　一旦执行这个动作命令，就相当于执行这个选择的区域。</p>
<p>　　a和i的区别。 i:表示的是inner，指的是区域内的文本;a:表示的是a，指的是一个完整的区域文本内容。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211736380379212.png" alt="" />　</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211736477876034.png" alt="" width="326" height="89" /></p>
<p>　　后面就只写区域名称，不一一写出来了，都是成对出现的。</p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>代表的文本区域</th></tr>
<tr>
<td>s</td>
<td>句子</td>
</tr>
<tr>
<td>p</td>
<td>段落</td>
</tr>
<tr>
<td>]或[</td>
<td>一个"]"块&nbsp;</td>
</tr>
<tr>
<td>)或(</td>
<td>一个"("块</td>
</tr>
<tr>
<td>}或{</td>
<td>一个"{"块</td>
</tr>
<tr>
<td>b</td>
<td>相当于一个"("块</td>
</tr>
<tr>
<td>B</td>
<td>相当于一个"{"块</td>
</tr>
<tr>
<td>&gt;或&lt;</td>
<td>一个"&lt;"块</td>
</tr>
<tr>
<td>t</td>
<td>一个tag blocks，相当于&lt;aa&gt;&lt;/aa&gt;</td>
</tr>
<tr>
<td>"</td>
<td>一个"""块</td>
</tr>
<tr>
<td>'</td>
<td>一个"'"块</td>
</tr>
</tbody>
</table>
<p><span style="line-height: 1.5;">　　详情可以查看:h object-select。</span></p>
<h1>滚屏</h1>
<p>　　当前窗口滚动文本内容显示。</p>
<p>　　z{count}CR(回车键)。设置窗口高度。</p>
<p>　　详情可以查看:h scroll.text ,:h xx。</p>
<h2>上下滚屏</h2>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211741109905223.png" alt="" width="449" height="346" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>CTRL+E&nbsp;</td>
<td>向下一行。光标一直往上走，直到顶到屏幕第一行，滚动的是内容</td>
</tr>
<tr>
<td>CTRL+Y&nbsp;</td>
<td>向上一行.光标一直往下走，直到顶到屏幕最后一行，滚动的是内容</td>
</tr>
<tr>
<td>Ctrl+D &nbsp;</td>
<td>向下半屏。光标在屏幕的相对位置不变，滚动的是内容</td>
</tr>
<tr>
<td>Ctrl+U &nbsp;</td>
<td>向上半屏。光标在屏幕的相对位置不变，滚动的是内容</td>
</tr>
<tr>
<td>CTRL+F &nbsp;</td>
<td>向下一屏。光标一直在第一行，滚动的是内容。</td>
</tr>
<tr>
<td>CTRL+B</td>
<td>&nbsp;向上一屏.光标一直在最后一行，滚动的是内容。</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2>屏幕不动光标动</h2>
<p>　　说明：屏幕里的内容不滚动，光标移动。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211632270371248.png" alt="" width="359" height="227" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>H</td>
<td>光标定位到当前屏幕最上行</td>
</tr>
<tr>
<td>M</td>
<td>光标定位到当前屏幕的中间行</td>
</tr>
<tr>
<td>L</td>
<td>光标定位到当前屏幕的最下行</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2>基于光标滚一屏</h2>
<p>　　说明：光标在原来的物理行位置不动，屏幕里的内容滚动最大值一屏。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/211742016628243.png" alt="" width="497" height="188" /></p>
<p>　　语法：</p>
<table class="myTable" style="width: 98%;" border="0">
<tbody>
<tr><th style="width: 150px;">动作命令</th><th>动作说明</th></tr>
<tr>
<td>zt</td>
<td>光标置于屏幕第一行，光标的列还是和移动之前一致。</td>
</tr>
<tr>
<td>z+</td>
<td>光标置于屏幕第一行。相当于z&lt;CR(回车键)&gt;，光标在于行首</td>
</tr>
<tr>
<td>zz</td>
<td>光标置于屏幕中文，光标的列还是和移动之前一致。</td>
</tr>
<tr>
<td>z.</td>
<td>光标置于屏幕中文，光标在于行首</td>
</tr>
<tr>
<td>zb</td>
<td>光标置于屏幕下方，光标的列还是和移动之前一致。</td>
</tr>
<tr>
<td>z-</td>
<td>光标置于屏幕最后一行，光标在于行首</td>
</tr>
</tbody>
</table>
<p><span style="line-height: 1.5;">　　注意事项：</span></p>
<ul>
<li><span style="line-height: 1.5;">z后面如果跟的是字母则停留在原来的位置，如果跟的是字符停留在行首</span></li>
</ul>
<p><span style="line-height: 1.5;">　　详情可以查看，:h z</span></p>
<h1>算术运算</h1>
<p>{count}ctrl+a　　加法</p>
<p>{count}ctrl+x　　减法</p>
<p>在做一些数字处理和校正时有用。例如</p>
<div class="cnblogs_code">
<pre><span style="color: #800000;">//要把第一个0px改为180px
.blog </span>{<span style="color: #ff0000;"> background-position</span>:<span style="color: #0000ff;"> 0px 0px </span>}<span style="color: #800000;">
//此时如果常规操作，f0s180&lt;ESC&gt;
//更快的操作就是使用算术运算，直接180Ctrl+A</span></pre>
</div>
<h1>宏</h1>
<p>语法：</p>
<p>　　定义宏：</p>
<p style="margin-left: 60px;">1、q{name}</p>
<p style="margin-left: 60px;">2、录制的命令</p>
<p style="margin-left: 60px;">3、q</p>
<p>　　使用宏：</p>
<p>　　　　${count}@{name}</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">要生成一个一百行的序列号
</span><span style="color: #008000;">//</span><span style="color: #008000;">先输入文本</span>
<span style="color: #800080;">1</span><span style="color: #000000;">、
</span><span style="color: #008000;">//</span><span style="color: #008000;">开始录制
</span><span style="color: #008000;">//</span><span style="color: #008000;">qayyp(Ctrl+A)q
</span><span style="color: #008000;">//</span><span style="color: #008000;">执行宏
</span><span style="color: #008000;">//</span><span style="color: #008000;">98@a</span></pre>
</div>
<h1>小技巧</h1>
<p>　　这些小技巧都出处于《vim实用技巧》，大家如果有兴趣可以进一步阅读学习。</p>
<h3>构造可重复的修改　</h3>
<div class="cnblogs_code">
<pre><span style="color: #000000;">假设光标位于行尾处的字符&ldquo;h&rdquo;上，而我们想要删除单词&ldquo;nigh&rdquo;：
The end is nigh<br /></span></pre>
</div>
<p>&nbsp;&nbsp;　我们尝试了3 种不同的方式来删除一个词：dbx、bdw 以及daw。他们高尔夫数（按键操作数）都是3，哪种方式最具重复性？我们针对这三种情况，都使用.命令操作一下。</p>
<p>　　dbx包含两步操作：db 命令删除至单词的开头，而后x 命令删除一个字符。如果我们跟着执行一次. 命令，它会重复删除一个字符（ . = = x ）。我不觉得这有什么价值。</p>
<p>　　bdw包含两步。这一次，b 只是一次普通的移动，而dw 完成修改。此时用. 命令会重复dw，删除从光标位置到下个单词开头的内容。不过因为我们刚好已经在行尾了，并没有&ldquo;下一个单词&rdquo;，所以在这个场景里. 命令没什么用。不过，至少它代表了一个更长点的操作（. = = dw）</p>
<p>　　daw只调用一个操作：daw。这个操作不仅仅删除了该单词，它还会删除一个空格，因此光标最终会停在单词&ldquo;is&rdquo;的最后一个字符上。如果此时我们使用. 命令，它会重复上次删除单词的命令。这一次， . 命令会做真正有用的事情（. = = daw）。</p>
<p>　　结论：daw 可以发挥. 命令的最大威力，因此我宣布它是本轮的获胜者。</p>
<p>　　如果你发现自己要在几个地方做同样的小修改，就可以尝试构造你的修改，让它们能够被. 命令重复执行。要识别出这类机会需要进行一定的实践，不过一旦你养成了使修改可重复的习惯，那么你就会从 Vim 这里得到&ldquo;奖赏&rdquo;。</p>
<h3>能够重复，就别用次数</h3>
<p>　　在处理某些特定工作时，使用次数可以使按键次数变得最少，不过我们并不是非得这样不可。我们需要认真考虑次数与重复各自的优缺点。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">假设在缓冲区里有如下文字：
Delete </span><span style="color: #0000ff;">more</span><span style="color: #000000;"> than one word
我们想把这段文字改为&ldquo;Delete one word&rdquo;，也就是说，要像这段文字里所讲的那样删除两个单词。</span></pre>
</div>
<p>&nbsp;　　我们的3 种选择d2w、2dw 或者dw. 都是3 次按键，不过哪一种最好呢？　</p>
<p>　　根据我们的讨论，d2w 和2dw 是相同的，在执行完两者中的任一个后，我们可以按u 键撤销，这样两个被删除的单词又会回来。或者，我们不是用撤销，而是用.命令重复执行它，这就会删除后面的两个单词。<br />　　对于dw. 的情形，按u 或. 的结果会有细微的差别。这里的修改是dw，即删除一个单词。因此，如果想恢复这两个被删除的单词，必须撤销两次，按uu（或者，如果你愿意，也可以按2u）。按. 则只删除后面的一个单词，而不是两个。<br />　　现在假设我们原本是想删除3 个单词，而不是2 个。由于判断出了点差错，我们执行了d2w 而不是d3w，那接下来怎么做？我们不能使用. 命令，因为那会总共删除4个单词。因此，我们或是先撤销而后修正次数（ud3w），或是继续删除下一个单词（dw）。<br />　　现在考虑另一种方案，如果我们在第一处地方用的是dw. 命令，那么我们只要再多重复一次. 命令就行了。因为我们最初的修改只是简单的dw，因此u 命令和. 命令都具有更细的粒度，每次只作用于一个单词。</p>
<p>　　现在假设我们想删除7 个单词，我们可以运行d7w，或是dw......（即dw 后面跟6 次. 命令）。计算一下按键的次数，哪个命令胜出是很显而易见的。不过你真地确信自己数对了次数吗？计算次数很是讨厌，因此我宁愿按6 次. 命令，也不愿意只为减少按键的次数，<br />　　而浪费同样的时间去统计次数。如果我多按了一次. 命令怎么办？没关系，只要按一次u 键就可以回退回来。</p>
<h3>只要必要的时候使用次数</h3>
<div class="cnblogs_code">
<pre>假设我们想把文字&ldquo;I have a couple of questions&rdquo;改为&ldquo;I have some more questions&rdquo;</pre>
</div>
<p>&nbsp;　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/220917579901935.png" alt="" width="484" height="89" /></p>
<p>　　在此场景中，使用. 命令的意义不大，我们可以删除一个单词，然后再用. 命令删除另一个，但随后我们还得切换到插入模式（例如，使用i 或cw）。对我来说这么做很不顺手，我反而更愿意用次数。<br />　　使用次数的另一个好处是：它保留了一个干净、连贯的撤销历史记录。完成这次修改后，我们按一下u 键就可以撤销整个修改。</p>
<h3>&nbsp;删除周边，修改内部</h3>
<div class="cnblogs_code">
<pre>假设，我们想删除下句中的单词&ldquo;excellent&rdquo;，此时可以用daw 命令：</pre>
</div>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/220924274907874.png" alt="" /></p>
<p>　　这条命令会删除此单词，外加一个空格，因此结果会很干净。如果我们用的是diw的话，那删完后就会有两个连在一起的空格，这或许并不是我们想要的。</p>
<div class="cnblogs_code">
<pre>现在假设我们是想把此单词改成另外一个单词，这次可以用ciw 命令：</pre>
</div>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/220925295843171.png" alt="" /></p>
<p>　　ciw 命令只删除该单词，而不删除其前后的空白字符，随后它会进入插入模式，这刚好是我们想要的效果。如果用的是caw 的话，那最后两个单词就会连在一起，变成&ldquo;mostadjectives&rdquo;。虽然这很容易修正，但如果一开始就能避免此问题，那岂不是更好么。</p>
<p>　　一般来说，d{motion} 命令和aw、as 和ap 配合起来使用比较好，而c{motion}命令和iw 及类似的文本对象一起用效果会更好。</p>]]></description></item><item><title>菜鸟vimer成长记——第2.0章、模式初探</title><link>http://www.cnblogs.com/ansn001/archive/2015/07/15/4646072.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Wed, 15 Jul 2015 02:42:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/07/15/4646072.html</guid><description><![CDATA[<p>　　首先，其他的文本编辑器只有一种模式，就是插入模式。而vim一下子颠覆了我们的世界观&mdash;&mdash;有好多模式。这个是思维上的切换，很难也很重要！！！</p>
<p>　　其次，Vim 提供一个区分模式的用户界面。也就是说在不同的模式下相同的键位可能产生的结果不一样。好多快捷怎么记忆？记忆后过段时间不使用又还给vim了。这个是因为没有弄清楚职责和使用场景，没有构建成套的vim知识体系。而我们这里通过模式为载体来构建vim知识体系。</p>
<h1>目的</h1>
<p>　　介绍vim的<em><strong>常用模式职责</strong></em>及<strong><em>模式切换</em></strong>，减少由于不断思考和纠正<em><strong>什么场景用什么模式的什么操作</strong></em>而引起的重复时间。</p>
<h1>简介</h1>
<p>　　模式主要有两大类：基础模式和衍生模式。每一类又有好多模式。更详细的可以直接使用:h vim-modes</p>
<p>　　这里主要讲的是基础模式里常用的4种模式。基于这4种模式会涉及到其他模式。</p>
<h1>常用模式职责</h1>
<p>　　职责主要从以下两个方面考虑</p>
<ul>
<li>独有：这个职责是本模式独有的，不可取代</li>
<li>擅长：这个职责是本模式相比其他模式的相同功能操作起来更快</li>
</ul>
<h2>insert</h2>
<h3>独有</h3>
<ul>
<li>当且仅当有输入当前文本不存在的新文本的需求时，才需要进到insert模式。<span style="line-height: 1.5;">如果没有前面的需求，不要随意的进入insert，因为来回切换很费时费力。</span></li>
</ul>
<h3><span style="line-height: 1.5;">擅长</span></h3>
<ul>
<li><span style="line-height: 1.5;">顺序的编辑文本内容时，当然这些编辑里必须有新的输入，不然也不应该使用insert模式。此时可以通过自动提示和寄存器更快捷的编辑文本，<em><strong>在编辑新文本的同时更快集成现有文本的操作</strong></em>。</span></li>
</ul>
<h2>visual</h2>
<p>　　？自己还没想太明白 。目前没有比较好的场景。欢迎大家一起学习讨论。</p>
<h2>normal</h2>
<h3>独有</h3>
<ul>
<li>行级别的光标移动：左右，单词移动</li>
<li>屏蔽滚动。</li>
<li>录制宏。</li>
</ul>
<h3>擅长</h3>
<p>　　一次快捷键直接可以直接选中区域的操作，然后直接执行动作。即一个移动+一个动作，之前有提到的理想状态。对比区别cmd-line的文本编辑场景。</p>
<h2>cmd-line</h2>
<h3>独有</h3>
<ul>
<li>从其他途径直接文本读写。从其他文件读入文本，从命令读入文本等。</li>
<li>文件操作。新建，保存，另存为，文件切换。</li>
<li>编辑器形为配置。通过 set，设置编辑器的形为。</li>
<li>调用shell命令。可以在编辑器里使用命令。</li>
</ul>
<h3>擅长</h3>
<ul>
<li>涉及到范围的文本编辑。直接进入命令模式，用一条完整的命令输入来解决，此时是先范围，然后再执行动作，思维更为完整。对比区别normal的文本编辑场景。</li>
</ul>
<h1>模式切换</h1>
<h2>模式切换的中转</h2>
<p>　　这个中转就是normal模式。</p>
<p>　　虽然有很多种模式。但是有些模式之间并不能切换。详情可以通过:h vim-modes查看</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/142216101737587.png" alt="" /></p>
<p>　　简单记忆：切换模式之前先退到normal模式，然后再进去要切换的模式。有些特殊模式切换会在下面记录</p>
<h2>常用切换</h2>
<h3>*--&gt;normal</h3>
<p>　　按Esc或者Ctrl+[，即可回到normal。网上也很多修改映射的。不过个人比较习惯按esc，刚好在切换模式，稍微调整一下思维，让紧张的思维缓和一下。</p>
<h3>normal--&gt;cmd-line</h3>
<p>　　按 /|?|：|!，即切换到cmd-line。</p>
<h3>normal--&gt;visual</h3>
<ul>
<li>快捷键：v，功能：自由选取</li>
<li>快捷键：ctrl+V，功能：列选取</li>
<li>快捷键：Shift+V,功能：行选取</li>
</ul>
<h3>normall--&gt;insert</h3>
<p>　　这个是最常用的切换模式。需要注意的是每一个操作都是一个独立的完整概念，都有其对应场景。</p>
<ul>
<li>快捷键：i， &nbsp;功能：在光标左侧输入正文。</li>
<li>快捷键：I， &nbsp;功能：在行首（不包括空白字符，比如空格）插入。</li>
<li>快捷键：gi， 功能：插入到上一次进入插入模式光标的位置。</li>
<li>快捷键：gI，功能：在行首插入（注意区别I）</li>
<li>快捷键：a， 功能：在光标后插入&nbsp;</li>
<li>快捷键：A， 功能：在行末插入</li>
<li>快捷键：s， 功能：删除光标所在的字符再插入</li>
<li>快捷键：S， 功能：删除整行再插入</li>
<li>快捷键：c， 功能：更灵活的插入，一般后面跟定位词（$,b,w,0等）,cc表示删除整行进入插入模式。</li>
<li>快捷键：C， 功能：删除光标到行末的内容再插入</li>
<li>快捷键：o， 功能：在当前行之下新建行</li>
<li>快捷键：O，功能：在当前行之上新建行</li>
</ul>
<h2>特殊切换</h2>
<h3>insert--&gt;insert normal</h3>
<p>　　这是一个特殊从insert切换到insert normal，输入Ctrl+O。此时会执行"<em><strong>一个"</strong></em>normal操作，然后继续返回insert</p>
<p>　　应用场景</p>
<ul>
<li>在当前行正好处于窗口顶部或底部时，有时我会滚动一下屏幕，以便看到更多的 上下文。用zz 命令可以重绘屏幕，并把当前行显示在窗口正中，这样就能够阅读当 前行之上及之下的半屏内容。我常常会键入&lt;C-o&gt;zz，在插入-普通模式中触发这条命 令。此操作完成后就会直接回到插入模式，因此我可以不受中断地继续打字。</li>
</ul>
<p>&nbsp;</p>
<hr />
<p style="text-align: center;">&nbsp;本文基于现在的认知所总结出来，在后续的学习中会不断持续修订认知。欢迎大家讨论指正。</p>
<hr />
<p>&nbsp;</p>]]></description></item><item><title>菜鸟vimer成长记——第1章、统一概念</title><link>http://www.cnblogs.com/ansn001/archive/2015/07/13/4642209.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 13 Jul 2015 13:19:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/07/13/4642209.html</guid><description><![CDATA[<p>　　不管学什么技术，我都深信概念是最重要的。是影响整个学习轨迹，决定能在这个技术领域高度。</p>
<p>　　当然如果你现在的目的不是在学习而在于解决问题（很多人不愿意承认，或者没发现），那概念就暂时没那么重要了。</p>
<h1>目的</h1>
<p>&nbsp;　　弄清楚这些概念,有助于记忆,举一反三。重复的东西只学一次！！</p>
<h1>用键盘不用鼠标</h1>
<p>　　第一关是理解vim的设计思路，vim设计之初就是整个文本编辑都用键盘而非鼠标来完成，键盘上几乎每个键都有固定的用法。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201507/131032281739732.png" alt="" width="888" height="627" /></p>
<p>　　具体有两个要注意的建议：</p>
<h2>学会盲打</h2>
<p>　　如果你要低头看着键盘打字，或者键位不熟悉，或者指法不舒服，那学习Vim 的好处不会立竿见影地显现出来。要高效地使用Vim，必须学会盲打。</p>
<h2>不要离开主键盘</h2>
<p>　　手指千万不要离开主键盘。很多人会说用光标键盘也没事，偶尔用一下或者设置一下鼠标。</p>
<p>　　不离开的理由：任何操作通过键盘都是可以完成的，只是不知道或者不熟悉而已，只要练习这些时间最终是可以被消除的。而回来切这中间是需要时间的，这些时间再怎么练习也是不可避免的。</p>
<h1>组合式的设计理念</h1>
<p>　　vim的学习，特别像汉字学习或者linux学习，通过组合。汉字你只要记几个部首和意义字，很多你没学过字组合在面前也能看得懂。linux，只要记住基本的命令，通过组合可以实现强大复杂的功能。</p>
<p>　　所以重点在于，<em><strong>通过各个维度划分快捷成独立概念。然后在操作的时候通过组合的方法去思维</strong></em>。</p>
<h2>每个快捷即是独立概念</h2>
<p>　　这里要描述的是概念，所以不会穷举快捷。具体的快捷到时会打散到各个模式里的常用操作。</p>
<p>　　比如：</p>
<ul>
<li>表示动作的有: d(删除),m(移动),co(复制),s(替换),y(复制)等</li>
<li>表示移动的有：$(词尾),0(词首),w|b|e(词),G(行),h|j|k|l(方向)等</li>
<li>表示重复的量词：n(表示任何正数)</li>
</ul>
<h2>组合这些概念来完成命令</h2>
<p>　　有一句话：越简单越灵活，实现的能力越强大。这是因为组合的存在。</p>
<p>　　比如：</p>
<ul>
<li>"dd" 删除当前行</li>
<li>"3dd" 删除三行</li>
<li>"d$" "d"表示删除，$"代表行尾,删除到行尾的内容(包含光标);</li>
<li>"dw" &nbsp;表示删除一个单词</li>
<li>"dG" &nbsp;表示删除到文件末尾</li>
<li>"dff" &nbsp;表示删除到第一个f</li>
</ul>
<h1>正则表达式</h1>
<p>　　vim的操作核心是文本，既然是文本必须会提到正则。如果正则不熟悉，那很多地方是很纠结的。</p>
<p>　　这里只描述vim使用正则的场景。这里我划分的是两大块内容：通过<em><strong>正则匹配定位到文本</strong></em>，然后通<em><strong>过动作去操作</strong></em>。</p>
<p>　　想了解更多正则，可以参考下面资源：</p>
<p>　　<a title="几个正则表达式文章" href="http://www.cnblogs.com/dwlsxj/tag/%E3%80%9001%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank">几个正则表达式文章</a></p>
<p>　　<a title="正则表达式30分钟入门教程" href="http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html#introduction" target="_blank">正则表达式30分钟入门教程</a></p>
<p>　　<a title="正则基础之&mdash;&mdash;NFA引擎匹配原理" href="http://blog.csdn.net/lxcnn/article/details/4304651" target="_blank">正则基础之&mdash;&mdash;NFA引擎匹配原理</a></p>
<h2>应用场景</h2>
<ul>
<li>查找(阅读):/|?</li>
<li>替换:s</li>
<li>删除:d</li>
<li>拷贝:co</li>
<li>移动:m</li>
</ul>
<p>　　更细则的东西将在normal模式里记叙。</p>
<h1>所有重复都可以被解决</h1>
<p>　　本质上讲，我们的工作是重复性的。不论是在几个不同的地方做相同的小改动，还是在文档的相似结构间移动，我们都会重复很多操作。凡是可以简化重复性操作的方式，都会成倍地节省我们的时间，都会被vim解决。</p>
<p>　　<em><strong>下面的举例只为说明问题，可能还不是最佳的方案。</strong></em></p>
<h2>文本操作</h2>
<p>　　vim通过：.命令,;命令,量词,history,宏,vimscript等手段来实现消除重复操作。</p>
<p>　　但是消除这些重复的关键是以下的思想</p>
<h3>不要自我重复</h3>
<p>　　举例说明：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">有以下的文本
</span><span style="color: #008000;">//</span><span style="color: #008000;">要实现的效果，每行递进缩进一行。</span>
<span style="color: #000000;">Line one
Line two
Line three
Line four
</span><span style="color: #008000;">//</span><span style="color: #008000;">千万不要这么操作
    </span><span style="color: #008000;">//</span><span style="color: #008000;">&gt;G
    </span><span style="color: #008000;">//</span><span style="color: #008000;">j &gt;G
    </span><span style="color: #008000;">//</span><span style="color: #008000;">j &gt;G
    </span><span style="color: #008000;">//</span><span style="color: #008000;">j &gt;G
</span><span style="color: #008000;">//</span><span style="color: #008000;">上面的做法不断再重复&gt;G这两个操作。
</span><span style="color: #008000;">//</span><span style="color: #008000;">合理一些的操作是
    </span><span style="color: #008000;">//</span><span style="color: #008000;">&gt;G
    </span><span style="color: #008000;">//</span><span style="color: #008000;">j .
    </span><span style="color: #008000;">//</span><span style="color: #008000;">j .
    </span><span style="color: #008000;">//</span><span style="color: #008000;">j .
</span><span style="color: #008000;">//</span><span style="color: #008000;">当然再合理一些是用宏录制或者还有其他办法</span></pre>
</div>
<p>　　只要是重复的任何操作都可以被解决。这点非常重复！</p>
<h3>&nbsp;绝不多使用一个命令</h3>
<p>　　举例说明：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">现在光标在行中间，但是发现行尾没有分号，或者说这行暂时不需要想给注释掉。
</span><span style="color: #008000;">//</span><span style="color: #008000;">千万不要这么做
    </span><span style="color: #008000;">//</span><span style="color: #008000;">移动$|0
    </span><span style="color: #008000;">//</span><span style="color: #008000;">按i
    </span><span style="color: #008000;">//</span><span style="color: #008000;">输出符号
</span><span style="color: #008000;">//</span><span style="color: #008000;">合理做法
    </span><span style="color: #008000;">//</span><span style="color: #008000;">直接使用I|A
    </span><span style="color: #008000;">//</span><span style="color: #008000;">输出符号</span></pre>
</div>
<p>　　只要一个命令可以完成的，坚决不使用二个或者多个命令。换句话说，每一个vim命令都是有原子的独立的概念，请最终独立记忆。　　</p>
<h3>使修改可重复</h3>
<p>　　举例说明：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">给+号左右都多加一个空格</span>
var foo = <span style="color: #800000;">"</span><span style="color: #800000;">method(</span><span style="color: #800000;">"</span> + argument1 +<span style="color: #800000;">"</span><span style="color: #800000;">,</span><span style="color: #800000;">"</span>+argument2+<span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">千万不要这么做：
    </span><span style="color: #008000;">//</span><span style="color: #008000;">f+
    </span><span style="color: #008000;">//</span><span style="color: #008000;">i空格-&gt;(移动光标)空格
    </span><span style="color: #008000;">//</span><span style="color: #008000;">f+ .
    </span><span style="color: #008000;">//</span><span style="color: #008000;">f+ .
</span><span style="color: #008000;">//</span><span style="color: #008000;">合理作法：
    </span><span style="color: #008000;">//</span><span style="color: #008000;">f+
    </span><span style="color: #008000;">//</span><span style="color: #008000;">s空格+空格
    </span><span style="color: #008000;">//</span><span style="color: #008000;">f+ .
    </span><span style="color: #008000;">//</span><span style="color: #008000;">f+ .</span></pre>
</div>
<p>　　首先，第一种使用了光标移动，这是很费时的，因为要在主键盘和光标区切换。其次也不能实现效果，因为.命令重复的是vim的操作，光标不包括在内。</p>
<p>　　所以很多时候要思考修改可被重复。&nbsp;</p>
<h3>使移动可重复</h3>
<p>　　上面的例子可以再简化。;命令会重复上次查找。因此后面可以输入两次按;即可。</p>
<p>　　所以，尽量让移动也可以重复。就可以使用;来简化。</p>
<h3>理想模式</h3>
<p>　　;命令带我们到下一个目标字符上，而.命令则重复上次的修改。因为连续输入2次;.就可以完成全部。<em><strong>最</strong><strong><em>理想的模式：用一键移动，另一键执行</em>。</strong></em></p>
<h2>IDE操作|个性化操作</h2>
<p>　　只要是重复的都可以被解决。上面说的是文本的重复操作解决方案。除了文本之外还有更多的重复。比如在不同使用功能时使用不同插件。根据自己的个人喜爱，把重复的设置通过配置文件来固化。</p>
<p>　　比如说</p>
<ul>
<li>在标记快速定位,可以使用ctags插件等。</li>
<li>你不用每次都set nu，不用每次都设置缩进。</li>
</ul>
<h1>回退everything</h1>
<p>　　当vim让一个操作或者移动可以方便地重复时，我们经常会不小心操作太快过了头。这时不用担心，vim提供了强大的回退机制。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">目的                          操作                      重复          回退 </span><span style="color: #008000;">
//</span><span style="color: #008000;">做出一个修改                   {edit}                    .              u </span><span style="color: #008000;">
//</span><span style="color: #008000;">在行内查找下一指定字符           f{char}/t{char}          ;              , </span><span style="color: #008000;">
//</span><span style="color: #008000;">在行内查找上一指定字符           F{char}/T{char}          ;              , </span><span style="color: #008000;">
//</span><span style="color: #008000;">在文档中查找下一处匹配项         /pattern&lt;CR&gt;              n              N </span><span style="color: #008000;">
//</span><span style="color: #008000;">在文档中查找上一处匹配项         ?pattern&lt;CR&gt;              n              N </span><span style="color: #008000;">
//</span><span style="color: #008000;">执行替换                      :s/target/replacement      &amp;              u </span><span style="color: #008000;">
//</span><span style="color: #008000;">执行一系列修改                 qx{changes}q              @x         　　 u </span></pre>
</div>
<p>&nbsp;</p>
<h1>模式</h1>
<p>　　Vim 提供一个区分模式的用户界面，就是 说在Vim中按键盘上的任意键所产生的结果可能会不一样，而这取决于当前处于哪种模式 （mode）。知道当前正处于哪种模式，以及如何在各模式间切换，是极其重要的。在后面的系列文章中，这个是重中之重，也会围绕着这些来记叙。主要记叙常用的4种模式。insert,normal,command-line,visual。</p>
<h1>无处不在的help</h1>
<p>　　有任何的不清楚或者想知道，都可以通过h: xx，来阅读更详细的帮助信息。</p>
<p>　　比如&nbsp;</p>
<ul>
<li>:h .</li>
<li>:h ;</li>
<li>:h vim-modes</li>
</ul>
<p>　　还有一个快捷键，K（Shift+k），它能给出你光标上的文本的帮助信息。</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<p>vim统一概念很多，不可能一下子所有列举出来。会在后面的文章边学习边总结边补充。如果大家有什么好的想法也欢迎一起探讨。</p>
<p>&nbsp;</p>]]></description></item><item><title>菜鸟vimer成长记——第0章、我眼中的vim学习</title><link>http://www.cnblogs.com/ansn001/archive/2015/07/10/4635978.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Fri, 10 Jul 2015 15:22:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/07/10/4635978.html</guid><description><![CDATA[<p>　　这是一系统总结vim的学习文章，记录我自己学习vim的过程和感悟。与此同时也想分享出来给大家，欢迎大家互相讨论和学习。</p>
<p>　　在这里假设你们对vim已经有了一些基本的认识或者说已经使用过几个月的vim。该系列文章里有些基础概念可能不会涉及到或者不会多做解释。一个是因为有些基础概念我目前也解释不清楚。越基础的解释起来越需要能力，目前鄙人还不具备。另一个是因为我相信各位大神们，你们已经有很好的搜索功能。当然有问题也欢迎大家互相讨论和学习。</p>
<p>　　这篇主要讲的是我当前对vim学习的理解。后面的一系列文章会针对于学习实战的&ldquo;从熟悉到精通&rdquo;具体展示记叙。</p>
<h1>困境</h1>
<p>　　从开始接触vim到现在快2年，陆陆续续学习vim不下5次。有看书，有看视频，有看博客&hellip;&hellip;，然后自己练着玩、工作环境中使用。然而我却陷入一个困境：每次使用的时候大概知道怎么用，不过还得上网搜，搜完再小心翼翼的试，试完后很爽，爽完后猛的发现已经浪费很多时间，然后下次场景重现，一直死循环。</p>
<p>　　所以本系列的文章就是为了摆脱这种困境而生。我是一个懒惰的人，不想花时间在重复的事情上。</p>
<h1>目的</h1>
<p>　　本系列的文章的目的有两个。一个是<em><strong>掌握</strong><strong>高效的文本编辑思维及习惯.</strong></em>一个是<em><strong>彻底消灭由文本编辑而引起的垃圾重复时间</strong></em>。</p>
<h1>定义</h1>
<p>　　vim是一个神一样的文本编辑器。它的核心是编辑文本。</p>
<h1>优点</h1>
<p>　　一直在各个地方找寻它的优点。论调很多，关键的是我可能暂时还没法区分。只是从我眼中直观来看，它有这么些优点</p>
<ul>
<li>无平台移植问题，无论是windows,linux还是mac，学一次一辈子都可以使用。</li>
<li>手不用离开键盘主要输入区，视线不用离开目标文本。用鼠标再切回来键盘打字是很低效的一件事，所以我特别喜欢快捷键，能不用鼠标的都不想用鼠标。</li>
<li>专注于内容建设要比排版重要，而Word显然做不到。对于程序猿来说，这是一件天大的喜事。</li>
</ul>
<h1>学习感受</h1>
<p>　　大家都在说vim的学习曲线，大概意思是门槛高，不过入了门就是飞一般的感受。没错这里我说的就是感受，划分这些感受是希望大家不会觉得孤单，其实我们都一样。也是希望大家能看到只要坚持，感受会越来越美妙。很多人使用vim，可能最终无奈的原因是服务器环境只能使用vim。其实vim最终可以像情人一样。</p>
<h2>恶梦，这是什么鬼</h2>
<p>　　一开始是notepad++, word, edit垄断你的大脑, 这些东西根深蒂固, 挥之不去Vim的使用对你而言是一场噩梦, <em><strong>它降低而不是提高了你的工作效率</strong>.</em> 对三种工作模式的不解甚至使你认为它是一个充满BUG或者至少是一个古怪的与当今友好用户界面设计严重脱节的软件。会不由自主的说：&ldquo;靠，这是什么鬼！&rdquo;</p>
<h2>食之无味，去之可惜</h2>
<p>　　开始熟悉一些基本的操作, 这些操作足以应付你日常的工作, 你使用这些操作时根本就不假思索. 但这些阶段你仍然很少去碰Vim那晦涩的在线帮助文档. 它在你心里只是notepad++, edit一个<strong><em>勉强合格的替代品</em></strong>。心里会泛起一阵阵忧伤:&ldquo;这东西好像也没什么牛逼的地方，和其他编辑器一样就是编辑文件嘛&rdquo;</p>
<h2>爱不释手，像情人一样</h2>
<p>　　&nbsp;精益求精的你不满足于无休无止的简单操作, 冗长而乏味,有没有更好的办法可以四两拔斤？ 你在第二阶段由于熟练操作而尘封已久的大脑突然开始运作.<em><strong>每一次的文本编辑体验都妙趣横生高潮迭起. 你的头脑因为要用Vim完成高效的编辑而高度紧张兴奋</strong></em>。就像和情人在一起一样，你会觉得它太美妙啦！！</p>
<h1>学习实战</h1>
<p>　　不管多少想法，最终必须得付之实践才有效果。vim学习更是如此。它必须大量反复的练习实战，直到已经成为一种本能反应。然后才能解决一开始的困境。网上有很多种实践的方式，不过划分比较细，可能不太适合像我这种懒的人。所以我只是简单的划分两个实战阶段。第一阶段主要是以苦练为主，加上习惯的练习。第二阶段是基于第一阶段的反思总结强化。</p>
<h2>从陌生到熟悉</h2>
<p>　　这个阶段主要是练，所以没什么好说的。第一个是我要实战的计划，后二个是我要实战培养的习惯。暂时不会展示记叙</p>
<h3>练习vimtutor</h3>
<p>　　必须完整的练vimtutor 3次以上。练到可以通过分屏，左边看tutor文档右边操作不会断。练到能自己画出vim的操作思维导图</p>
<h3>随时看帮助文档</h3>
<p>　　先通读两遍以上，因为太强大了。。。所有功能里面都有</p>
<p>　　帮助文档太强大了！！！ :help everything。养成习惯有任何不清楚的地方都看help一下，通过help去处理细节问题。</p>
<h3>无时不刻使用vim</h3>
<p>　　不管你工作的系统是什么，都必须无时不刻使用vim。特别是对于windows的用户，请装一个gvim。</p>
<p>&nbsp;</p>
<h2>从熟悉到精通</h2>
<p>　　<em><strong>这个也是本系列文章的主体内容</strong></em>。通过记叙的方式，把学习vim的过程和感悟记录下来。</p>
<p>　　具体准备划分成如下几块去展开进行。更细的，请关注后续更新的文章。每一块可能会根据其结构更新苦干文章。</p>
<h3>vim涉及到的概念</h3>
<p>　　vim涉及很多<strong><em>文本操作概念，设计理念等</em></strong>，这些概念适合用整个vim操作。所以首先要做的就是把概念弄清楚，更多的是锻炼思维习惯。</p>
<h3>vim常用模式经典操作</h3>
<p>　　基于统一概念对<strong><em>常用的4种模式</em></strong>里面的经典操作逐一记叙，让平常的文本编辑重复操作彻底消除</p>
<h3>让vim更懂你</h3>
<p>　　每个人的习惯，以及工作场景（有的编写js,html,python,shell等）都不一样。所以除了文本编辑以外，还会<strong><em>插件</em></strong>和<strong><em>配置</em></strong>，这些会让我们使用起来更安逸。进一步消除更多的重复工作，消除重复由人手设置引起的垃圾重复时间</p>
<hr />
<p>最后祝愿每一个菜鸟vimer都能尽快成为vimer大神，享受神器带来的快感！！！！</p>]]></description></item><item><title>基于分布式、服务化的maven项目文件规划</title><link>http://www.cnblogs.com/ansn001/archive/2015/06/26/4598430.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Fri, 26 Jun 2015 09:02:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/06/26/4598430.html</guid><description><![CDATA[<h1>引言</h1>
<p>此文不是纯粹介绍maven概念，而是介绍一个具体的<strong><span style="color: #0000ff;">maven项目文件规划</span></strong></p>
<p>这个规划可能适合于研发比较复杂的业务，这些业务有<strong><span style="color: #0000ff;">分布式</span></strong>和<strong><span style="color: #0000ff;">服务化</span></strong>的需要。</p>
<p>这个规划能够解决因为分布式和服务化要求而引起的项目繁多，项目混乱的问题。</p>
<p>与此同时这个规划也可以解决了在项目研发中出现的重复&ldquo;轮子&rdquo;的问题。这些&ldquo;轮子&rdquo;主要来源于两类：</p>
<ol>
<li>代码的重复&ldquo;轮子&rdquo;，所以要抽取项目，导致项目数量进一步增多。</li>
<li>人工构建项目的重复&ldquo;轮子&rdquo;，构建的关系越来越复杂，错误率也越来越高，所以要通过基于配置和约定的方法来实现自动化构建。</li>
</ol>
<p>其他的不多赘述，直接上干货。</p>
<h1><span style="font-size: 1em; line-height: 1.5;">实际的规划图</span></h1>
<p><img src="http://images0.cnblogs.com/blog2015/762312/201506/261652039089699.png" alt="" /></p>
<h1>所有parent的公用职责</h1>
<ol>
<li>构建它下面聚合的所有项目。约定是只聚合它子目录的项目，不能跨目录去聚合</li>
<li>管理它聚合的项目的通用特性，即存在继承关系。这些通用特性，是从它聚合的项目本身抽取的职责而来。约定这个继承和聚合使用同一个项目。</li>
<li><span style="line-height: 1.5;">统一管理它聚合的项目中使用依赖其他项目或者jar的版本。聚合的项目只允许依赖它下层的项目。具体分层，看下文的分层依赖关系</span></li>
</ol>
<h1>we-parent的职责</h1>
<p>　　职责：一键构建所有需要发布的项目。</p>
<p>　　通用特性：</p>
<ol>
<li>所有项目初始时就带有这些jar包的依赖，例如：testng(单元测试相关),h2(单元测试相关),easymock(单元测试相关),lombok（根据注释自动生成setter和getter）</li>
<li>所有项目的额外特性，例如：单元测试插件</li>
<li>项目发布管理，例如：私一的maven私服配置</li>
</ol>
<h1><span style="line-height: 1.5;">we-core-parent的职责</span></h1>
<p><span style="line-height: 1.5;">　　职责：它所聚合的的项目与业务没有关联的，只提供基础能力。简称：core项目。例如：数据库持久能力，redis缓存能力,http封装能力，通用工具能力等。</span></p>
<p><span style="line-height: 1.5;">　　通用特性：</span></p>
<ul>
<li><span style="line-height: 1.5;">Javadoc插件，用于生成javadoc</span></li>
</ul>
<h1><span style="line-height: 1.5;">we-base-parent的职责</span></h1>
<p><span style="line-height: 1.5;">　　职责：它所聚合的的项目有且只能代表一个<strong>真实存在</strong>而且能<strong>独立存在</strong>的<strong>核心实体</strong>对应的业务，简称：base项目。</span></p>
<p><span style="line-height: 1.5;">　　概念解释：</span></p>
<ul>
<li><span style="line-height: 1.5;">真实存在：即可以用一个具体的客观物体承载的。比如：用户，课程，试题</span></li>
<li><span style="line-height: 1.5;">独立存在：不依赖于其他的任何业务，放在哪里都可以独自呈现。比如：试题放在哪里都可以显示，课程放在任何地方也可以呈现。</span></li>
<li><span style="line-height: 1.5;">核心实体：一个业务服务其实通过一个实体就可以来实现了，顶多是字段属性多一些、实现复杂一些。为了更好的实现，我们可以会把这个实体拆分成很多。但是不管拆分多少个实体，总会有一个是最为重要的，其他的实体如果没有这个实体就没有任何意义。比如试题抽象成试题实体和答案实体。如果没有试题的存在，答案是没有存在的意义的。所以试题就是核心实体。</span></li>
</ul>
<p><span style="line-height: 1.5;">　　通用特性：暂无</span></p>
<h1><span style="line-height: 1.5;">we-business-parent的职责</span></h1>
<p><span style="line-height: 1.5;">　　职责：它所聚合的的项目必须是一个提供<strong>&ldquo;共享&rdquo;</strong>业务流程，简称：business项目。在这个流程过程中有可能需要引用base服务。它本身没有一个<strong>真实存在</strong>而且能<strong>独立存在</strong>的<strong>核心实体</strong></span></p>
<p><span style="line-height: 1.5;"><strong>　　</strong>概念解释：</span></p>
<p><span style="line-height: 1.5;">　　共享：在产品规划上，该服务可能会被多个产品使用，即为共享。</span></p>
<p><span style="line-height: 1.5;">　　通用特性：</span></p>
<ul>
<li><span style="line-height: 1.5;">统一引用数据库持久能力，即数据库实现项目。</span></li>
</ul>
<h1><span style="line-height: 1.5;">we-web-parent的职责</span></h1>
<p><span style="line-height: 1.5;">　　职责：它所聚合的的项目可以通过互联网向用户提供服务，在产品规划上它自己<strong>独有的不被共享</strong>的业务，简称：web项目。</span></p>
<p><span style="line-height: 1.5;">　　通用特性：</span></p>
<ul>
<li><span style="line-height: 1.5;">统一引用http解析能力。对http的解析及渲染。</span></li>
<li><span style="line-height: 1.5;">监控相关</span></li>
</ul>
<h1><span style="line-height: 1.5;">分层依赖关系</span></h1>
<p><span style="line-height: 1.5;">除了we-parent，每一个parent对应的职责就是一个项目分层。这些项目分层的从上到下的关系如下图。</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　<img src="http://images0.cnblogs.com/blog2015/762312/201506/261628164866218.png" alt="" width="307" height="270" /></span></p>
<h1><span style="line-height: 1.5;">如何使用</span></h1>
<p><span style="line-height: 1.5;">　　假设：现在来一个产品稿（prd，原型或者定稿需求）</span></p>
<p><span style="line-height: 1.5;">　　使用步骤如下：</span></p>
<ol>
<li><span style="line-height: 1.5;">分析一下，这个产品是否要对用户独立提供服务，不受其他的产品影响。如果要，则新建web项目。</span></li>
<li><span style="line-height: 1.5;">分析一下，这个产品有没有哪些业务是准备被其他产品使用的，即在其他产品的界面有没有体现本产品。</span></li>
<li><span style="line-height: 1.5;">如果有，分析一下这些公用的业务，有没有包含一个流程性，即它的业务在组合其他已有base项目。如果有，新建一个business项目</span></li>
<li>分析一下，这个产品有没有可以独立存在，不依赖于任何其他服务的业务。如果有，新建一个base项目。</li>
<li>当实现这些编码时，如果有遇到一些与业务无关的，只提供能力的，则新建一个core项目。</li>
</ol>
<p>　　总结来说：就是分析的时候根据分层，从上到下。把每一层的职责分析一下，如果有则新建一个。每一个项目，都必须建在对应的parent之下。</p>
<p>&nbsp;</p>]]></description></item><item><title>基于git的工作流程</title><link>http://www.cnblogs.com/ansn001/archive/2015/06/23/4594863.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Tue, 23 Jun 2015 02:34:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/06/23/4594863.html</guid><description><![CDATA[<p>本文针对的是追求极致、快速的产品响应团队的。以下的观点和内容都是围绕这个主题，暂时不涉及个人学习和团队学习。</p>
<hr />
<p>&nbsp;</p>
<p>在说工作流程之间，想说一下我们平常工作中遇到的一些困惑或者说现象</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">在一个团队里，同时有好多事件要解决。有的是产品迭代，有的是bug修改，有的可能是技术结构调整等。怎么去保证他们之间的独立性？

什么时候应该切分支？合并后的分支还能再作修改吗？分支什么时候需要删除？什么时候这个分支的生命周期才算完成？

主干可以修改代码吗？多少次分支合并到主干才发布一个版本？

什么时候版本才算稳定。什么时候才需要打标记？<br />&hellip;&hellip;&hellip;&hellip;<br /></span></pre>
</div>
<p>&nbsp;</p>
<p>可能期间还会有更多的疑问。但是汇总起来是以下两个问题：</p>
<ul>
<li>团队里不是每个人都能完整的回答或者解决这个问题，所以导致很多人在重复的去思考这些问题。</li>
<li>怎么避免因为误操作而引起的产品不完整。</li>
</ul>
<p>这两个问题，也是我们工作流的目的。</p>
<p>下面我就把git的几个概念及生命周期应用于工作中的职责阐述一下。</p>
<p>分支的职责：</p>
<p><img src="http://images0.cnblogs.com/blog2015/762312/201506/231739030026377.png" alt="" width="959" height="311" /></p>
<p>主干的职责：</p>
<p><img src="http://images0.cnblogs.com/blog2015/762312/201506/231739557362567.png" alt="" width="963" height="346" /></p>
<p><img src="http://images0.cnblogs.com/blog2015/762312/201506/231022147206754.png" alt="" /></p>
<p>描述清楚职责后，工作流程如下：</p>
<p><img src="http://images0.cnblogs.com/blog2015/762312/201506/231740332525339.png" alt="" width="958" height="823" /></p>
<p>最后希望，通过统一的git开发式的工作流程来进行快速的持续迭代。或者说最终目的是：<span style="color: #ff00ff;"><strong>希望团队里的成员只专注业务，与业务无关的通过约定、规范、流程来规避</strong></span>。</p>]]></description></item><item><title>怎么构建创业型技术团队所需要的软件</title><link>http://www.cnblogs.com/ansn001/archive/2015/06/15/4578496.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Mon, 15 Jun 2015 08:37:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/06/15/4578496.html</guid><description><![CDATA[<p>　　最近一直有一件事困惑着我&mdash;&mdash;怎么样才能高效的让团队只专注于业务或者说产品。</p>
<p>　　当然这是一个很大的话题。所以我先找到了一个切入点：怎么样使用软件才能更高效。希望先把客观存在的问题先解决。</p>
<hr />
<p>　　</p>
<p>　　首先，软件是为了解决真正问题而存在于团队的。所以哪些软件才是团队真正需要的，必须先从团队真正存在的问题来说起。</p>
<p>　　每个团队的定位不同，所以必然导致使用的软件不同。这里我以我们现在的团队为蓝本进行尝试解惑。</p>
<p>　　</p>
<p>　　我们团队的定位是：专注产品、快速响应的团队。我们是一个解决问题型团队，不是一个学习型团队。所以不会兼顾太基础或者说成体系的技术积累，也不会涉及太多太新潮或者研究性的技术积累。</p>
<p>　　基于上面的定位，软件可以分为下面这几个部分：</p>
<ol>
<li>　 &nbsp; 搭建技术环境。</li>
<li>&nbsp; &nbsp; &nbsp; 项目管理。</li>
<li>&nbsp; &nbsp; &nbsp; 团队的技术知识积累。</li>
</ol>
<p>&nbsp;</p>
<p>　　<span style="font-size: 18px;"><strong>搭建技术环境</strong></span></p>
<p>　　目的：把一个产品通过技术手段变成一个用户可使用的产品。即可以通过客户端来访问。</p>
<p>　　这个环境不需要每个人都熟悉一次。只要有一个稳定的版本就可以了。不需要花费其他兄弟的精力在这上面。这套东西必须是可以自动化持续集成的。</p>
<p>　　这个环境每个人的职责定义可能不同。我就抛一个我们现在在使用搭建方法。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201506/151617468414480.png" alt="" width="1189" height="840" /></p>
<p>&nbsp;</p>
<p>&nbsp;　　<span style="font-size: 18px;"><strong>项目管理</strong></span></p>
<p>　　目的：以最优的方式去实现产品。减少不可确定性。</p>
<p>　　这里是以敏捷开发为模型的项目管理。我们这里使用的worktile。所有的工作内容重心都围绕着产品的项目来实现。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201506/151626396232714.png" alt="" width="1151" height="517" /></p>
<p>&nbsp;</p>
<p>　　<span style="font-size: 18px;"><strong>团队的技术知识积累</strong></span></p>
<p>　　目的：减少使用开发软件的时间成本、减少遇到开发软件问题时解决问题的时间成本。</p>
<p>　　我们这里，只专注于团队里使用的软件。</p>
<p>　　<img src="http://images0.cnblogs.com/blog2015/762312/201506/151630216385019.png" alt="" width="1093" height="417" /></p>
<p>&nbsp;</p>
<p>综上：</p>
<ul>
<li>环境搭建的软件我们不希望其他成员分心，一般都已经做自动化搭建。</li>
<li>项目管理的软件，我们把所有工作重心都放在上面，专注用户故事、专注迭代，尽可能的减少项目周期。</li>
<li>技术知识的积累围绕着团队正在使用的技术去积累。主要是为了减少时间，也希望通过反复使用熟悉这些正在使用的技术。也许以后有一定感悟，可以以博客的方式，把更高层次的技术展示出来。</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;最后强烈推荐两款软件：为知和worktile</p>
<p>&nbsp;</p>]]></description></item><item><title>druid之监控设置及问题小记</title><link>http://www.cnblogs.com/ansn001/archive/2015/06/12/4571606.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Fri, 12 Jun 2015 06:26:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/06/12/4571606.html</guid><description><![CDATA[<p>druid是什么注不再赘述了。想了解直接参见</p>
<p><a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" target="_blank">https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</a></p>
<p>本文主要记录监控相关部分</p>
<p>1、怎么配置监控</p>
<p>2、注意点</p>
<p>3、应用场景</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong>配置监控</strong></span></p>
<p><strong>1.打开监控统计</strong></p>
<p><strong>　　核心配置是这个，一般通过ioc来配置。需要注意的参数是这个</strong></p>
<div class="cnblogs_code">
<pre>filters : 'stat,wall'</pre>
</div>
<p>　　'stat'用于统计，'wall'用于防火墙</p>
<p><strong>2.展示监控统计</strong></p>
<p><strong>在web.xml里配置</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 展示Druid的统计信息,统计数据源和sql  </span><span style="color: #008000;">--&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">servlet</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">servlet-name</span><span style="color: #0000ff;">&gt;</span>DruidStatView<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">servlet-name</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">servlet-class</span><span style="color: #0000ff;">&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">servlet-class</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 白名单 </span><span style="color: #008000;">--&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>allow<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>192.168.1.120/24,111.206.116.68,127.0.0.1<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 用户名 </span><span style="color: #008000;">--&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>loginUsername<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>account<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 密码 </span><span style="color: #008000;">--&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>loginPassword<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>tyts<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">servlet</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">servlet-mapping</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">servlet-name</span><span style="color: #0000ff;">&gt;</span>DruidStatView<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">servlet-name</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">url-pattern</span><span style="color: #0000ff;">&gt;</span>/druid/*<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">url-pattern</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">servlet-mapping</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 如果需要监控uri，设置Web关联监控配置 </span><span style="color: #008000;">--&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>DruidWebStatFilter<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-class</span><span style="color: #0000ff;">&gt;</span>com.alibaba.druid.support.http.WebStatFilter<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter-class</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>exclusions<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-name</span><span style="color: #0000ff;">&gt;</span>
            <span style="color: #008000;">&lt;!--</span><span style="color: #008000;"> 排除统计干扰 </span><span style="color: #008000;">--&gt;</span>
            <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">param-value</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">init-param</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-mapping</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>DruidWebStatFilter<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter-name</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">url-pattern</span><span style="color: #0000ff;">&gt;</span>/*<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">url-pattern</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">filter-mapping</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p><strong><span style="font-size: 18pt;">注意点</span><br /></strong></p>
<p><strong>1.访问权限（这里有两层限制）</strong></p>
<ul>
<li><strong>　　限定指定的ip可以访问。</strong></li>
<li><strong>　　需要通过用户名和密码才可以进入展示页面</strong></li>






</ul>
<p><strong><strong>限定指定的ip</strong></strong></p>
<p><strong><strong>规则：</strong></strong></p>
<p><strong><strong>　　如果是限定指定ip，可以直接写完整的ip。例如111.206.116.68。</strong></strong></p>
<p><strong><strong>　　如果是限定指定的子网里的所有ip都可以访问，那就是ip/子网掩码数。例如 192.168.1.120/24 就相当于192.168.1.*</strong></strong></p>
<p><strong><strong>通过用户名和密码</strong></strong></p>
<p><strong><strong>　　看web.xml里的例子即可。功能本身就带有。</strong></strong></p>
<p><strong><strong>2.统计的filters</strong></strong></p>
<p><strong><strong>　　druid提供了一些内置filter实例。这里用的是stat和wall。一个是用于监控，一个是用于防火墙</strong></strong></p>
<p><strong><strong>　　如果想使用sql防火墙，必须加上wall</strong></strong></p>
<p><strong><strong>3.weburi-detail.html详情页里不能显示带.json后缀的uri详情，因为在druid的代码进行了处理</strong></strong></p>
<div class="cnblogs_code">
<pre> <span style="color: #0000ff;">if</span> (url.startsWith("/weburi-") &amp;&amp; url.indexOf(".json") &gt; 0<span style="color: #000000;">) {
            String uri </span>= StringUtils.subString(url, "weburi-", ".json"<span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> returnJSONResult(RESULT_CODE_SUCCESS, getWebURIStatData(uri));
        }</span></pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 18pt;"><strong><strong>应用场景（或者说监控页面关注的选项）</strong></strong></span></p>
<p><span style="font-size: 18px;"><strong><strong>数据源</strong></strong></span></p>
<p><strong><strong>　　连接数设置，</strong></strong><strong style="line-height: 1.5;"><strong>事务及连接数使用情况以及使用详细情况</strong></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 18px;"><strong><strong>SQL监控</strong></strong></span></p>
<p><strong><strong>　　执行时间，最慢，读取行数，最大并发数，以及时间分布。不一一说明</strong></strong></p>
<p><strong><strong>　　<img src="http://images0.cnblogs.com/blog2015/762312/201506/121418166607030.png" alt="" width="1311" height="367" /></strong></strong></p>
<p><span style="font-size: 18px;"><strong><strong>SQL防火墙</strong></strong></span></p>
<p><strong><strong>　　可以看出表的使用情况</strong></strong></p>
<p><strong><strong>　　<img src="http://images0.cnblogs.com/blog2015/762312/201506/121414186605007.png" alt="" width="1308" height="389" /></strong></strong></p>
<p><span style="font-size: 18px;"><strong><strong>Web应用</strong></strong></span></p>
<p><strong><strong>　　并发，请求数，来源于哪个类型操作系统，来源于哪些浏览器</strong></strong></p>
<p><span style="font-size: 18px;"><strong><strong>URI监控</strong></strong></span></p>
<p><strong><strong>　　请求次数，请求时间，最大并发，区间分布</strong></strong></p>
<p><strong><strong>　　<img src="http://images0.cnblogs.com/blog2015/762312/201506/121417351768702.png" alt="" width="1345" height="287" /></strong></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><strong>参考资料：</strong></strong></p>
<p><a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" target="_blank"><strong><strong>https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</strong></strong></a></p>
<p><a href="http://blog.csdn.net/blogdevteam/article/details/7750513" target="_blank"><strong><strong>http://blog.csdn.net/blogdevteam/article/details/7750513</strong></strong></a></p>
<p><a href="http://blog.csdn.net/renfufei/article/details/39553639" target="_blank"><strong><strong>http://blog.csdn.net/renfufei/article/details/39553639</strong></strong></a></p>
<p>&nbsp;</p>]]></description></item><item><title>怎么样进行轻松高效的代码复读</title><link>http://www.cnblogs.com/ansn001/archive/2015/06/09/4562583.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Tue, 09 Jun 2015 01:37:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/06/09/4562583.html</guid><description><![CDATA[<p>为了弄清这个问题，我们想一起同步统一一下代码复读的用途或者说目的。</p>
<ul>
<li>知识传播</li>
<li>学习提高</li>
<li>统一风格</li>
</ul>
<p><br /><strong>知识传播</strong><br />有一个更酷更快捷的技能，思路，算法，编码习惯，工具类等。希望团队里的其他大神能以更短的时候学会。主观者（分享者），主动想往外去推给其他被动者（复读者）。达到大家一起越来越牛X。</p>
<p><strong>学习提高</strong><br />对很多知识：规范，习惯，算法，思路，业务，不够熟悉。主观者（复读者），主动想去复读别人的代码。达到提升自己水平或者说靠近团队风格。</p>
<p><strong>统一风格</strong><br />不管是传播、学习、还是相互修改bug。统一的风格都是一个团队必需的。就像谷歌里的小猴子说过的：我在看别人代码的时候，就感觉像自己写的一样，很轻松。这里面包括：基本规范，编码习惯，甚至是思维习惯等。</p>
<hr /><hr />
<p>&nbsp;</p>
<p>基于上面的几个目的，我抛个砖。我们的代码复读以后的方式，可能更多的是这样：</p>
<p>1. 如果作者，有比较cool的代码（语法，算法，思路）想分享给大家学习或者让大家看看有没有更牛的方法想。可以指定分享给谁去看这段代码。</p>
<p>2. 如果作者，在写某些代码的时候有困惑或者觉得写得不好，可以指定给谁，让大家帮你复读一下，看有没有更好的做法。</p>
<p>3. 如果学习者，抱着挑刺的目的去。这个时候就是大家来找茬。找到荐可以TODO给作者。让作者去修改或者讨论。</p>
<p>4. 如果学习者，抱着学习的目的去。这个时候就可以看看别人写的代码。验证基本规范，编码习惯，思维习惯等</p>]]></description></item><item><title>Linux基础命令之拷贝文件——cp</title><link>http://www.cnblogs.com/ansn001/archive/2015/05/27/4533770.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Wed, 27 May 2015 08:25:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/05/27/4533770.html</guid><description><![CDATA[<p>命令之类的网上有一大推。就不赘述了。这里主要是针对日常使用的场景，记录一下使用方式。</p>
<p>场景：</p>
<p>1、如果要复制一个同名配置文件替到指定的位置，又要把原来的备份一下，那就可以使用-b这个指令了。操作的结果是生成一个以&ldquo;~&rdquo;结尾的备份文件</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>参考资源：</p>
<p>http://www.cnblogs.com/xilifeng/archive/2012/10/13/2722602.html</p>]]></description></item><item><title>读报笔记——我只是早起了15分钟而已</title><link>http://www.cnblogs.com/ansn001/archive/2015/05/27/4532561.html</link><dc:creator>庄君祥</dc:creator><author>庄君祥</author><pubDate>Wed, 27 May 2015 01:38:00 GMT</pubDate><guid>http://www.cnblogs.com/ansn001/archive/2015/05/27/4532561.html</guid><description><![CDATA[<div>Bel言简意赅地介绍了5个能让梦想破碎的陷阱<br />&nbsp;<br />1.&nbsp;<strong>相信一夜成名</strong>。你肯定听过这样的故事： 一个技术男开发了一个移动应用并迅速转卖赚大赚一笔。 这个故事可能是真的，但是很可能是不完整的。 如果你深入研究就发现， 这个人在之前已经开发了30个应用， 他还有相关的硕士和博士学历， 他研究这个领域已经20年了。</div>
<p>2.<strong>&nbsp;相信别人会给你答案</strong>。周围的人，你的家人、朋友、商业伙伴会告诉你什么是最好的，但没人会知道什么是最合适你的。没有人能给你的人生提供完美的答案，你还需做出其他的选择， 并且你需要自己做出这些选择。</p>
<p>3.&nbsp;<strong>相信一时的成功足矣</strong>。&nbsp;&ldquo;还可以&rdquo;&nbsp;是永远不够的。 当你朝着一个顶峰前进的时候， 你需要更加努力来找到另一个顶峰。 当你能够看到另一个顶峰时，其实就没有时间止步。</p>
<p>4.&nbsp;<strong>相信永远是别人的错</strong>。经常有人说 &ldquo;没有遇到有远见的投资者&rdquo; &ldquo;我有个很棒的产品， 但是市场行情太糟糕&rdquo; 或者，&ldquo;找不到人才，团队实在太差了。&rdquo; 如果你有梦想， 让梦想实现是你的责任。如果没有实现，也是你的责任。</p>
<p>5.&nbsp;<strong>相信梦想本身最重要</strong>。人们往往觉得实现梦想的时候应该是最美妙绝伦的时刻，那里被鲜花掌声与荣誉环绕。 但其实梦想实现只是短暂的一瞬， 而你的人生不会停留在这一瞬。也许迈出下一步，就是滑坡。真正实现梦想的最好办法就是尽情享受起起伏伏的旅途。<br /><br /><strong><em>运气就是日积月累的实力爆发的时刻</em></strong></p>]]></description></item></channel></rss>