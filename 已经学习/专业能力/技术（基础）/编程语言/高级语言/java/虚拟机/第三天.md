### 对象实例数据
实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无底是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略和Java源码中定义顺序的影响。
相同宽度的被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。
### 对齐填充
并不是必然存在的，它仅仅起着占位符的作用。VM的自动内存管理系统要求对象起始地址必须是8字节的整数部。对象实例数据如果不是8的位数，需要通过对齐填充来补齐。

## 对象的访问定位
>建立对象是为了使用对象。
Java程序需要通过栈上的reference数据来操作堆上的具体对象。
目前主要的访问试有使用句柄和直接指针两种。

区别是在对象实体数据的指针VS对象类型数据的指针。
句柄池的话是存放这两个指针，然后分配指到Java堆里实例池里的对象及方法区里的对象类型数据
指针是直接指向Java堆里的对象，对象里包括一个对象类型数据的指针。

句柄的好处，对象移动时只会改变句柄中的实例数据指针，而引用本身不需要修改
指针的好处，节省一次指定定位的时间开销。
Java虚拟机使用的是第二种。

 >小结：内存的分配，对象的创建、对象的访问。

## 实战：OME异常
除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。
介绍几个内存相关的最基本的参数

* 通过代码验证虚拟机中规范描述的各个运行时区域存储的内容;
* 遇到实际的内存溢出异常时，能根据异常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出。

### Java堆溢出
保证保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象。
> 比较严重的问题时，一启动就报错，可以设置jvm启动参数


```
-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError

java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid13468.hprof ...
Heap dump file created [27922463 bytes in 0.087 secs]
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
    at java.util.Arrays.copyOf(Arrays.java:3210)
    at java.util.Arrays.copyOf(Arrays.java:3181)
    at java.util.ArrayList.grow(ArrayList.java:261)
    at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)
    at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)
    at java.util.ArrayList.add(ArrayList.java:458)
    at jvm.HeapOOM.main(HeapOOM.java:29)
```
通过内存映像分析工具（eclipse memory analyzer)对dump出来的堆转储快照进来分析，重点是确认内存中的对象是否是必要的。
如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC 相关联并导致垃圾器无法自动回收它们的。
> 掌握泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。

如果不存在泄露，即内存中的对象确实都还必须存活着，那就应该检查虚拟机堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大。
从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况。

### 虚拟机栈和本地方法栈溢出

> 栈容量只由-Xss参数设定

实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError?

多线程可以产生内存溢出。为每个线程的栈分配的内存越大，反而越容易产生内存溢出。
> 栈总空间，每个线程空间

操作系统 分配给每个进程的内存是有限的，譬如32位的windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。
剩余的内存为2GB（操作系统限制）减少Xmx(最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。
如果虚拟机进程本身消耗的内存不计算在内，剩下的内存就由虚拟机栈和本地方法“瓜分”。每个线程分配到的栈容易越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。

减少最大堆和减少栈容易来换取更多的线程。

> unable to create native thread

### 方法区和运行时常量池溢出
增强的类越多，就需要越大的来Class可以加载入内存
大量JSP或动态生产JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGI的应用

### 本机直接内存溢出
>-XX:MaxDirectMemorySize
如果不指定，默认与Java堆最大值（-Xms）一样

如果发现OOM之后Dump文件很小，而又直接或者间接使用NIO，那就可以考虑检查一下是不是这方面的原因 

# 本章小结
通过本章的学习，我们明白了虚拟机中的内存是如何划分的，哪部分区域、什么样的代码和操作可能导致内存溢出异常。

先定位是哪一部分的问题










